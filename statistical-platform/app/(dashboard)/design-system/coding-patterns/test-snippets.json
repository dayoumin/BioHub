{
  "id": "test-snippets",
  "version": "1.8.0",
  "lastUpdated": "2025-11-27",
  "sources": [
    "statistical-platform/__tests__/",
    "statistical-platform/jest.config.js"
  ],
  "categories": [
    {
      "name": "React Component Tests",
      "description": "React 컴포넌트 테스트 패턴",
      "patterns": [
        {
          "name": "기본 렌더링 테스트",
          "purpose": "컴포넌트가 정상적으로 렌더링되는지 확인",
          "code": "import { render, screen } from '@testing-library/react';\nimport { MyComponent } from '@/components/MyComponent';\n\ndescribe('MyComponent', () => {\n  it('기본 렌더링이 정상적으로 동작해야 함', () => {\n    render(<MyComponent />);\n    \n    expect(screen.getByText('Hello')).toBeInTheDocument();\n    expect(screen.getByRole('button')).toBeInTheDocument();\n  });\n});",
          "keywords": [
            "render",
            "screen",
            "getByText",
            "toBeInTheDocument"
          ]
        },
        {
          "name": "이벤트 핸들링 테스트",
          "purpose": "사용자 이벤트(클릭, 입력 등)가 정상 동작하는지 확인",
          "code": "import { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport { MyComponent } from '@/components/MyComponent';\n\ndescribe('MyComponent 이벤트', () => {\n  it('버튼 클릭 시 콜백이 호출되어야 함', async () => {\n    const handleClick = jest.fn();\n    render(<MyComponent onClick={handleClick} />);\n    \n    fireEvent.click(screen.getByRole('button'));\n    \n    await waitFor(() => {\n      expect(handleClick).toHaveBeenCalledTimes(1);\n    });\n  });\n  \n  it('입력 필드에 텍스트 입력 시 상태가 업데이트되어야 함', () => {\n    render(<MyComponent />);\n    \n    const input = screen.getByPlaceholderText('Enter text');\n    fireEvent.change(input, { target: { value: 'Hello' } });\n    \n    expect(input).toHaveValue('Hello');\n  });\n});",
          "keywords": [
            "fireEvent",
            "click",
            "change",
            "waitFor"
          ]
        },
        {
          "name": "비동기 데이터 로딩 테스트",
          "purpose": "비동기 데이터 로딩 및 로딩 상태 확인",
          "code": "import { render, screen, waitFor } from '@testing-library/react';\nimport { MyComponent } from '@/components/MyComponent';\nimport { fetchData } from '@/lib/api';\n\njest.mock('@/lib/api');\nconst mockFetchData = fetchData as jest.MockedFunction<typeof fetchData>;\n\ndescribe('MyComponent 비동기', () => {\n  it('로딩 중에는 스피너가 표시되어야 함', async () => {\n    mockFetchData.mockImplementation(() => \n      new Promise(resolve => setTimeout(() => resolve([]), 1000))\n    );\n    \n    render(<MyComponent />);\n    \n    // 로딩 스피너 확인\n    expect(screen.getByRole('status')).toBeInTheDocument();\n    \n    // 데이터 로딩 완료 후\n    await waitFor(() => {\n      expect(screen.queryByRole('status')).not.toBeInTheDocument();\n    });\n  });\n  \n  it('데이터 로딩 실패 시 에러 메시지가 표시되어야 함', async () => {\n    mockFetchData.mockRejectedValue(new Error('Failed to fetch'));\n    \n    render(<MyComponent />);\n    \n    await waitFor(() => {\n      expect(screen.getByText(/Failed to fetch/)).toBeInTheDocument();\n    });\n  });\n});",
          "keywords": [
            "mock",
            "mockResolvedValue",
            "mockRejectedValue",
            "waitFor"
          ]
        }
      ]
    },
    {
      "name": "Schema Validation Tests",
      "description": "스키마 검증 테스트 패턴 (통계 결과 일관성 보장)",
      "patterns": [
        {
          "name": "카테고리별 필수 필드 검증",
          "purpose": "통계 방법별 필수 필드 존재 여부 확인",
          "code": "import { describe, it, expect } from '@jest/globals';\nimport { validateResultSchema, getCategoryForMethod } from '@/lib/validation/result-schema-validator';\nimport type { AnalysisResult } from '@/types/smart-flow';\n\ndescribe('Result Schema Validator', () => {\n  it('should pass when all required fields exist', () => {\n    const result: AnalysisResult = {\n      method: 'Independent t-test',\n      statistic: 2.5,\n      pValue: 0.05,\n      interpretation: 'Significant difference found'\n    };\n\n    const validation = validateResultSchema(result, 't-test');\n\n    expect(validation.valid).toBe(true);\n    expect(validation.missing).toHaveLength(0);\n    expect(validation.category).toBe('comparison');\n  });\n\n  it('should fail when required field is missing', () => {\n    const result = {\n      method: 'regression',\n      statistic: 15.3,\n      pValue: 0.001,\n      interpretation: 'Model fit'\n      // missing additional.rSquared\n    } as AnalysisResult;\n\n    const validation = validateResultSchema(result, 'regression');\n\n    expect(validation.valid).toBe(false);\n    expect(validation.missing).toContain('additional.rSquared');\n  });\n});",
          "keywords": [
            "schema validation",
            "required fields",
            "category mapping"
          ]
        },
        {
          "name": "Method ID 정규화 검증",
          "purpose": "다양한 method ID 형식이 올바른 카테고리로 매핑되는지 확인",
          "code": "describe('Method ID Normalization', () => {\n  it('should map executor-facing IDs correctly', () => {\n    // executor에서 사용하는 짧은 ID들\n    expect(getCategoryForMethod('simple')).toBe('regression');\n    expect(getCategoryForMethod('multiple')).toBe('regression');\n    expect(getCategoryForMethod('logistic')).toBe('regression');\n  });\n\n  it('should normalize method IDs with spaces', () => {\n    expect(getCategoryForMethod('t test')).toBe('comparison');\n    expect(getCategoryForMethod('chi square')).toBe('goodnessOfFit');\n  });\n\n  it('should handle case insensitive method IDs', () => {\n    expect(getCategoryForMethod('T-TEST')).toBe('comparison');\n    expect(getCategoryForMethod('ANOVA')).toBe('comparison');\n  });\n\n  it('should default to comparison for unknown methods', () => {\n    expect(getCategoryForMethod('unknown-method')).toBe('comparison');\n  });\n});",
          "keywords": [
            "method ID",
            "normalization",
            "case insensitive"
          ]
        },
        {
          "name": "배치 검증 테스트",
          "purpose": "여러 결과를 동시에 검증하고 실패한 method 식별",
          "code": "import { validateBatch } from '@/lib/validation/result-schema-validator';\n\ndescribe('Batch Validation', () => {\n  it('should validate multiple results at once', () => {\n    const results = [\n      { methodId: 't-test', result: { method: 't-test', statistic: 2.5, pValue: 0.05, interpretation: 'Significant' } },\n      { methodId: 'regression', result: { method: 'regression', statistic: 15.3, pValue: 0.001, interpretation: 'Model fit' } }\n    ];\n\n    const batch = validateBatch(results);\n\n    expect(batch.allValid).toBe(false);\n    expect(batch.failedMethods).toContain('regression');\n    expect(batch.failedMethods).not.toContain('t-test');\n  });\n});",
          "keywords": [
            "batch validation",
            "multiple results",
            "failed methods"
          ]
        }
      ]
    },
    {
      "name": "Integration Tests",
      "description": "통합 테스트 패턴 (프론트-백엔드 연결)",
      "patterns": [
        {
          "name": "데이터 구조 검증",
          "purpose": "프론트 → Python Worker 데이터 구조 일치 확인",
          "code": "import { describe, it, expect } from '@jest/globals';\n\ndescribe('ANOVA Integration Tests', () => {\n  it('데이터 구조가 Python Worker와 일치해야 함', () => {\n    // 프론트에서 준비하는 데이터 구조\n    const dataValues = [10, 12, 14, 16, 18, 20];\n    const factor1Values = ['A', 'A', 'B', 'B', 'C', 'C'];\n    \n    // 검증: 배열 길이 일치\n    expect(dataValues.length).toBe(factor1Values.length);\n    \n    // 검증: 최소 데이터 (4개 이상)\n    expect(dataValues.length).toBeGreaterThanOrEqual(4);\n    \n    // 검증: 데이터 타입\n    expect(Array.isArray(dataValues)).toBe(true);\n    expect(dataValues.every(v => typeof v === 'number')).toBe(true);\n  });\n});",
          "keywords": [
            "integration",
            "data validation",
            "Python Worker"
          ]
        },
        {
          "name": "Python Worker 파라미터 검증",
          "purpose": "Python Worker 호출 시 파라미터 형식 확인",
          "code": "import { describe, it, expect } from '@jest/globals';\n\ndescribe('Python Worker 파라미터', () => {\n  it('파라미터가 올바른 형식이어야 함', () => {\n    const params = {\n      data_values: [10, 12, 14, 16],\n      factor1_values: ['A', 'A', 'B', 'B'],\n      factor2_values: ['Low', 'High', 'Low', 'High']\n    };\n    \n    // 검증: 필수 키 존재\n    expect(params).toHaveProperty('data_values');\n    expect(params).toHaveProperty('factor1_values');\n    expect(params).toHaveProperty('factor2_values');\n    \n    // 검증: snake_case 사용 (Python 규약)\n    expect(Object.keys(params)).toEqual([\n      'data_values',\n      'factor1_values',\n      'factor2_values'\n    ]);\n  });\n});",
          "keywords": [
            "parameters",
            "snake_case",
            "validation"
          ]
        },
        {
          "name": "Python Worker 반환값 검증",
          "purpose": "Python Worker 반환값이 TypeScript 타입과 일치하는지 확인",
          "code": "import { describe, it, expect } from '@jest/globals';\n\ndescribe('Python Worker 반환값', () => {\n  it('반환 타입이 TwoWayANOVAResult와 일치해야 함', () => {\n    // Python Worker 반환 예상 구조\n    const mockResult = {\n      factor1: {\n        fStatistic: 5.2,\n        pValue: 0.032,\n        df: 1\n      },\n      factor2: {\n        fStatistic: 3.8,\n        pValue: 0.067,\n        df: 1\n      },\n      interaction: {\n        fStatistic: 2.1,\n        pValue: 0.165,\n        df: 1\n      },\n      residual: {\n        df: 8\n      }\n    };\n    \n    // 검증: 필수 필드 존재\n    expect(mockResult).toHaveProperty('factor1');\n    expect(mockResult).toHaveProperty('factor2');\n    expect(mockResult).toHaveProperty('interaction');\n    expect(mockResult).toHaveProperty('residual');\n    \n    // 검증: 숫자 타입\n    expect(typeof mockResult.factor1.fStatistic).toBe('number');\n    expect(typeof mockResult.factor1.pValue).toBe('number');\n  });\n});",
          "keywords": [
            "return type",
            "validation",
            "TypeScript"
          ]
        }
      ]
    },
    {
      "name": "Mock Patterns",
      "description": "모킹 패턴 (외부 의존성 격리)",
      "patterns": [
        {
          "name": "함수 모킹",
          "purpose": "외부 함수를 모킹하여 테스트 격리",
          "code": "import { myFunction } from '@/lib/utils';\n\njest.mock('@/lib/utils');\nconst mockMyFunction = myFunction as jest.MockedFunction<typeof myFunction>;\n\ndescribe('함수 모킹', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n  \n  it('함수가 호출되어야 함', () => {\n    mockMyFunction.mockReturnValue(42);\n    \n    const result = mockMyFunction(10);\n    \n    expect(mockMyFunction).toHaveBeenCalledWith(10);\n    expect(result).toBe(42);\n  });\n  \n  it('비동기 함수 모킹', async () => {\n    mockMyFunction.mockResolvedValue({ data: 'success' });\n    \n    const result = await mockMyFunction();\n    \n    expect(result).toEqual({ data: 'success' });\n  });\n});",
          "keywords": [
            "jest.mock",
            "mockReturnValue",
            "mockResolvedValue"
          ]
        },
        {
          "name": "모듈 모킹",
          "purpose": "전체 모듈을 모킹하여 복잡한 의존성 제거",
          "code": "// Mock markdown dependencies (ESM modules)\njest.mock('remark-gfm', () => ({}));\njest.mock('remark-breaks', () => ({}));\njest.mock('react-markdown', () => ({\n  __esModule: true,\n  default: ({ children }: { children: string }) => <div>{children}</div>\n}));\n\n// Mock 컴포넌트\njest.mock('@/components/rag/chat-sources-display', () => ({\n  ChatSourcesDisplay: () => <div data-testid=\"chat-sources\">Sources</div>\n}));\n\ndescribe('모듈 모킹', () => {\n  it('모킹된 컴포넌트가 렌더링되어야 함', () => {\n    render(<MyComponent />);\n    \n    expect(screen.getByTestId('chat-sources')).toBeInTheDocument();\n  });\n});",
          "keywords": [
            "jest.mock",
            "__esModule",
            "module mocking"
          ]
        },
        {
          "name": "window 객체 모킹",
          "purpose": "브라우저 API (window.open, localStorage 등) 모킹",
          "code": "const mockWindowOpen = jest.fn();\nconst mockLocalStorage = {\n  getItem: jest.fn(),\n  setItem: jest.fn(),\n  removeItem: jest.fn(),\n  clear: jest.fn()\n};\n\ndescribe('window 객체 모킹', () => {\n  beforeEach(() => {\n    window.open = mockWindowOpen;\n    Object.defineProperty(window, 'localStorage', {\n      value: mockLocalStorage,\n      writable: true\n    });\n  });\n  \n  it('window.open이 호출되어야 함', () => {\n    render(<MyComponent />);\n    \n    fireEvent.click(screen.getByText('새 창 열기'));\n    \n    expect(mockWindowOpen).toHaveBeenCalledWith('/chatbot', '_blank');\n  });\n  \n  it('localStorage가 호출되어야 함', () => {\n    mockLocalStorage.getItem.mockReturnValue('saved-value');\n    \n    render(<MyComponent />);\n    \n    expect(mockLocalStorage.getItem).toHaveBeenCalledWith('key');\n  });\n});",
          "keywords": [
            "window.open",
            "localStorage",
            "browser API"
          ]
        },
        {
          "name": "IndexedDB graceful degradation",
          "purpose": "브라우저 호환성 (Safari/Firefox에서 미지원 API 처리)",
          "code": "describe('IndexedDB cleanup graceful degradation', () => {\n  it('indexedDB.databases가 undefined일 때도 에러 없이 처리되어야 함', async () => {\n    // Safari/Firefox 시뮬레이션: databases 메서드가 없음\n    const mockIndexedDB = {\n      deleteDatabase: jest.fn(),\n      // databases 메서드 없음 (undefined)\n    };\n\n    Object.defineProperty(window, 'indexedDB', {\n      value: mockIndexedDB,\n      writable: true,\n    });\n\n    const cleanupIndexedDB = async () => {\n      try {\n        if (typeof window.indexedDB.databases === 'function') {\n          const databases = await window.indexedDB.databases();\n          for (const db of databases) {\n            if (db.name) {\n              window.indexedDB.deleteDatabase(db.name);\n            }\n          }\n        }\n      } catch (e) {\n        console.warn('[Settings] IndexedDB cleanup failed:', e);\n      }\n    };\n\n    await expect(cleanupIndexedDB()).resolves.not.toThrow();\n    expect(mockIndexedDB.deleteDatabase).not.toHaveBeenCalled();\n  });\n\n  it('indexedDB.databases가 에러를 던져도 graceful하게 처리되어야 함', async () => {\n    const consoleWarnSpy = jest.spyOn(console, 'warn').mockImplementation();\n    const mockIndexedDB = {\n      databases: jest.fn().mockRejectedValue(new Error('Not supported')),\n      deleteDatabase: jest.fn(),\n    };\n\n    Object.defineProperty(window, 'indexedDB', {\n      value: mockIndexedDB,\n      writable: true,\n    });\n\n    // ... cleanup 로직 ...\n    await expect(cleanupIndexedDB()).resolves.not.toThrow();\n    expect(consoleWarnSpy).toHaveBeenCalled();\n    consoleWarnSpy.mockRestore();\n  });\n});",
          "keywords": [
            "indexedDB",
            "browser compatibility",
            "feature detection",
            "graceful degradation",
            "Safari",
            "Firefox"
          ]
        }
      ]
    },
    {
      "name": "Regression Tests",
      "description": "회귀 테스트 패턴 (버그 재발 방지)",
      "patterns": [
        {
          "name": "Method Matching Regression",
          "purpose": "메서드명 매칭 로직의 버그 수정 검증",
          "code": "import { getInterpretation } from '@/lib/interpretation/engine';\nimport type { AnalysisResult } from '@/types/smart-flow';\n\ndescribe('T-Test Method Matching Regression Tests', () => {\n  describe('Independent Samples t-test - should match', () => {\n    it('Independent t-test (basic)', () => {\n      const results: AnalysisResult = {\n        method: 'Independent t-test',\n        pValue: 0.03,\n        statistic: 2.5,\n        interpretation: ''\n      };\n\n      const interpretation = getInterpretation(results);\n\n      expect(interpretation).not.toBeNull();\n      expect(interpretation?.title).toContain('t');\n    });\n  });\n\n  describe('Non-t-test methods with \"independent\" - should NOT match t-test', () => {\n    it('Independent KS Test should NOT match t-test', () => {\n      const results: AnalysisResult = {\n        method: 'Independent KS Test',\n        pValue: 0.02,\n        statistic: 0.35,\n        interpretation: ''\n      };\n\n      const interpretation = getInterpretation(results);\n\n      // Should return null or match a different interpretation (not t-test)\n      if (interpretation !== null) {\n        expect(interpretation.title).not.toContain('t');\n      }\n    });\n  });\n});",
          "keywords": [
            "regression",
            "method matching",
            "interpretation engine",
            "pattern matching"
          ]
        }
      ]
    },
    {
      "name": "Test Setup & Teardown",
      "description": "테스트 설정 및 정리 패턴",
      "patterns": [
        {
          "name": "beforeEach / afterEach",
          "purpose": "각 테스트 전/후 설정 및 정리",
          "code": "describe('MyComponent', () => {\n  beforeEach(() => {\n    // 각 테스트 전에 실행\n    jest.clearAllMocks();\n    localStorage.clear();\n  });\n  \n  afterEach(() => {\n    // 각 테스트 후에 실행\n    jest.restoreAllMocks();\n  });\n  \n  it('테스트 1', () => {\n    // ...\n  });\n  \n  it('테스트 2', () => {\n    // ...\n  });\n});",
          "keywords": [
            "beforeEach",
            "afterEach",
            "setup",
            "teardown"
          ]
        },
        {
          "name": "beforeAll / afterAll",
          "purpose": "모든 테스트 전/후 한 번만 실행",
          "code": "describe('MyComponent', () => {\n  beforeAll(() => {\n    // 모든 테스트 전에 한 번만 실행\n    console.log('테스트 시작');\n  });\n  \n  afterAll(() => {\n    // 모든 테스트 후에 한 번만 실행\n    console.log('테스트 종료');\n  });\n  \n  it('테스트 1', () => {\n    // ...\n  });\n  \n  it('테스트 2', () => {\n    // ...\n  });\n});",
          "keywords": [
            "beforeAll",
            "afterAll",
            "global setup"
          ]
        },
        {
          "name": "테스트 격리 (Isolation)",
          "purpose": "각 테스트가 독립적으로 실행되도록 보장",
          "code": "describe('격리된 테스트', () => {\n  let mockData: any;\n  \n  beforeEach(() => {\n    // 각 테스트마다 새로운 데이터 생성\n    mockData = {\n      id: Math.random(),\n      name: 'Test',\n      items: []\n    };\n  });\n  \n  it('테스트 1이 mockData를 수정해도', () => {\n    mockData.name = 'Modified';\n    expect(mockData.name).toBe('Modified');\n  });\n  \n  it('테스트 2는 원본 mockData를 받음', () => {\n    // beforeEach로 새로 생성됨\n    expect(mockData.name).toBe('Test');\n  });\n});",
          "keywords": [
            "isolation",
            "independent tests",
            "fresh data"
          ]
        }
      ]
    },
    {
      "name": "Pyodide Worker Tests",
      "description": "Pyodide Worker 매핑 검증 테스트 패턴",
      "patterns": [
        {
          "name": "Worker-Function 매핑 검증",
          "purpose": "TypeScript에서 호출하는 함수가 실제 Python Worker 파일에 존재하는지 검증",
          "code": "extractFunctionsFromWorker(workerNum): Worker 파일에서 def function_name( 패턴으로 함수 추출\n\nEXPECTED_MAPPINGS: { worker: number, function: string, tsMethod: string }[]\n\nit(`${tsMethod}() → Worker ${worker}의 ${pyFunc}() 함수가 존재해야 함`, () => {\n  expect(workerFunctions[worker]).toContain(pyFunc);\n});",
          "keywords": [
            "Worker",
            "Pyodide",
            "function mapping",
            "Python"
          ]
        },
        {
          "name": "양방향 동기화 검증 (Bidirectional Sync)",
          "purpose": "서비스 메서드 추가/삭제 시 EXPECTED_MAPPINGS 업데이트를 강제하여 누락 방지",
          "code": "// 1. 서비스 파일에서 메서드 추출\nfunction extractServiceMethods() {\n  const content = readFileSync(SERVICE_PATH, 'utf8')\n  const pattern = /asyncs+(w+).*callWorkerMethod.*((d),.*['\"]([w_]+)['\"]/g\n  // ... 추출 로직\n}\n\n// 2. 양방향 검증 테스트\nit('서비스의 모든 메서드가 EXPECTED_MAPPINGS에 등록되어 있어야 함', () => {\n  const serviceMethods = extractServiceMethods()\n  const testedMethods = EXPECTED_MAPPINGS.map(m => m.tsMethod)\n  const untestedMethods = serviceMethods.filter(m => !testedMethods.includes(m.tsMethod))\n  \n  if (untestedMethods.length > 0) {\n    throw new Error('EXPECTED_MAPPINGS에 추가하세요: ' + untestedMethods.map(m => m.tsMethod))\n  }\n})\n\nit('EXPECTED_MAPPINGS의 모든 메서드가 서비스에 존재해야 함', () => {\n  // 삭제된 메서드 감지 → EXPECTED_MAPPINGS에서도 제거 강제\n})",
          "keywords": [
            "Bidirectional",
            "Sync",
            "동기화",
            "양방향",
            "EXPECTED_MAPPINGS"
          ]
        },
        {
          "name": "파라미터 시그니처 검증 (Parameter Signature)",
          "purpose": "TypeScript → Python 파라미터 이름/개수 일치 여부 검증",
          "code": "// 파라미터 시그니처 검증 테스트\n// 목적: 런타임 TypeError 사전 방지\n\n// 1. Python 함수 파라미터 추출\nfunction extractPythonFunctionParams(workerNum, funcName) {\n  const content = readFileSync(workerPath, 'utf8')\n  const pattern = new RegExp(`def ${funcName}\\\\(([^)]*)\\\\)`, 'm')\n  const match = content.match(pattern)\n  return match[1].split(',').map(p => p.split('=')[0].trim())\n}\n\n// 2. TypeScript 서비스 파라미터 키 추출\nfunction extractServiceCallParams(tsMethod) {\n  // callWorkerMethod(N, 'func', { key1, key2: value }) 에서 키 추출\n}\n\n// 3. 검증 테스트\nit('twoWayAnova 파라미터가 일치해야 함', () => {\n  const pyParams = extractPythonFunctionParams(3, 'two_way_anova')\n  expect(pyParams).toContain('data_values')\n  expect(pyParams).toContain('factor1_values')\n  expect(pyParams).toContain('factor2_values')\n})\n\n// 검증 항목:\n// - 필수 파라미터 존재 여부\n// - 파라미터 이름 일치 (snake_case)\n// - 최소 파라미터 개수",
          "keywords": [
            "parameter",
            "signature",
            "파라미터",
            "TypeError",
            "런타임"
          ]
        }
      ]
    },
    {
      "name": "Pyodide Worker Architecture",
      "description": "Pyodide Worker 매핑 구조 이해 및 관리 방법",
      "patterns": [
        {
          "name": "3계층 매핑 구조 (3-Layer Mapping)",
          "purpose": "TypeScript → Service → Python Worker 호출 흐름 이해",
          "code": "// === 3계층 매핑 구조 ===\n//\n// 1. TypeScript 메서드 (pyodide-core.service.ts)\n//    async twoSampleTTest(group1: number[], group2: number[]): Promise<StatisticsResult>\n//\n// 2. callWorkerMethod 호출 (Worker 번호 + Python 함수명)\n//    return this.callWorkerMethod<StatisticsResult>(2, 't_test_two_sample', { group1, group2 })\n//                                                   ^        ^\n//                                                   |        |\n//                                       Worker 번호(1-4)   Python 함수명\n//\n// 3. Python Worker 실행 (worker2-hypothesis.py)\n//    def t_test_two_sample(group1, group2):\n//        from scipy import stats\n//        return stats.ttest_ind(group1, group2)\n\n// === Worker 구성 ===\n// Worker 1: scipy만 (가벼움) - normality_test, descriptive_stats, outlier_detection\n// Worker 2: scipy + statsmodels (중간) - t-tests, chi-square, correlation\n// Worker 3: scikit-learn (무거움) - nonparametric + ANOVA + post-hoc\n// Worker 4: scikit-learn (무거움) - regression + PCA + factor + cluster",
          "keywords": [
            "3-layer",
            "mapping",
            "callWorkerMethod",
            "Worker"
          ]
        },
        {
          "name": "Worker 선택 최적화",
          "purpose": "가벼운 함수는 Worker 1/2, 무거운 함수는 Worker 3/4 사용",
          "code": "// Worker 로딩 시간 차이 (scikit-learn 여부)\n//\n// Worker 1: scipy only       → ~2초  (기본 통계)\n// Worker 2: scipy+statsmodels → ~3초  (가설 검정)\n// Worker 3: +scikit-learn    → ~8초  (비모수 + ANOVA)\n// Worker 4: +scikit-learn    → ~8초  (회귀 + 고급)\n//\n// 최적화 원칙:\n// - 간단한 통계 (평균, 정규성, 이상치) → Worker 1\n// - 가설 검정 (t-test, chi-square)    → Worker 2\n// - 비모수 + ANOVA                    → Worker 3\n// - 회귀 + 고급 분석                  → Worker 4\n\n// ✅ 올바른 Worker 선택\nawait this.ensureWorker1Loaded()  // scipy만 필요한 함수\nreturn this.callWorkerMethod(1, 'descriptive_stats', { data })\n\n// ❌ 잘못된 Worker 선택 (불필요하게 무거운 Worker 사용)\nawait this.ensureWorker4Loaded()  // scikit-learn 불필요한데 Worker 4 사용\nreturn this.callWorkerMethod(4, 'descriptive_stats', { data })",
          "keywords": [
            "optimization",
            "Worker 선택",
            "scikit-learn",
            "로딩 시간"
          ]
        },
        {
          "name": "함수명 규칙 (snake_case)",
          "purpose": "Python Worker 함수명은 snake_case 사용 필수",
          "code": "// Python Worker 함수명 규칙\n//\n// ✅ 올바른 함수명 (snake_case)\n// def t_test_two_sample(group1, group2):\n// def chi_square_test(observed, expected):\n// def one_way_anova(groups):\n//\n// ❌ 잘못된 함수명\n// def tTestTwoSample()  // camelCase 금지\n// def TwoSampleTTest()  // PascalCase 금지\n// def two-sample-ttest()  // kebab-case 금지\n//\n// TypeScript 메서드명 → Python 함수명 매핑\n// twoSampleTTest()    → t_test_two_sample\n// chiSquareTest()     → chi_square_test\n// oneWayANOVA()       → one_way_anova\n// simpleLinearRegression() → linear_regression",
          "keywords": [
            "snake_case",
            "naming convention",
            "함수명"
          ]
        },
        {
          "name": "매핑 검증 테스트 추가 방법",
          "purpose": "새 함수 추가 시 EXPECTED_MAPPINGS에 등록",
          "code": "// 새 Worker 메서드 추가 시 EXPECTED_MAPPINGS 업데이트 필수!\n// 파일: __tests__/pyodide/worker-function-mapping.test.ts\n\nconst EXPECTED_MAPPINGS = [\n  // ... 기존 매핑 ...\n\n  // 새로 추가하는 함수\n  {\n    worker: 3,                    // Python Worker 번호 (1-4)\n    function: 'dunn_test',        // Python 함수명 (snake_case)\n    tsMethod: 'dunnTestWorker'    // TypeScript 메서드명 (camelCase)\n  },\n]\n\n// 양방향 동기화로 자동 감지:\n// 1. 서비스에 메서드 추가 → 테스트 실패 → EXPECTED_MAPPINGS에 추가\n// 2. 서비스에서 메서드 삭제 → 테스트 실패 → EXPECTED_MAPPINGS에서 제거\n// 3. Python에 함수 없음 → 테스트 실패 → Python Worker에 함수 구현",
          "keywords": [
            "EXPECTED_MAPPINGS",
            "테스트",
            "새 함수 추가"
          ]
        },
        {
          "name": "현재 Worker별 함수 목록",
          "purpose": "2025-11-27 기준 Worker별 함수 배치",
          "code": "// Worker 1 (scipy only - 가벼움)\n// - normality_test       (shapiroWilkTest)\n// - descriptive_stats    (descriptiveStats)\n// - outlier_detection    (outlierDetection)\n// - cronbach_alpha       (cronbachAlpha)\n// - one_sample_proportion_test (oneSampleProportionTest)\n// - bonferroni_correction (performBonferroni)\n\n// Worker 2 (scipy + statsmodels - 중간)\n// - t_test_two_sample    (twoSampleTTest)\n// - t_test_paired        (pairedTTest)\n// - t_test_one_sample    (oneSampleTTest)\n// - z_test               (zTestWorker)\n// - chi_square_test      (chiSquareTest)\n// - binomial_test        (binomialTestWorker)\n// - correlation_test     (correlationTest)\n// - partial_correlation  (partialCorrelationWorker)\n// - levene_test          (leveneTest)\n\n// Worker 3 (scikit-learn - 무거움, 비모수 + ANOVA)\n// - mann_whitney_test, wilcoxon_test, kruskal_wallis_test\n// - friedman_test, sign_test, runs_test, mcnemar_test\n// - cochran_q_test, mood_median_test\n// - one_way_anova, two_way_anova, repeated_measures_anova\n// - ancova, manova\n// - tukey_hsd, scheffe_test, games_howell_test\n\n// Worker 4 (scikit-learn - 무거움, 회귀 + 고급)\n// - linear_regression, multiple_regression, logistic_regression\n// - pca_analysis, factor_analysis, cluster_analysis",
          "keywords": [
            "Worker 목록",
            "함수 배치",
            "현재 상태"
          ]
        },
        {
          "name": "검증 테스트 요약 (Verification Summary)",
          "purpose": "Worker 매핑 테스트가 검증하는 항목 일람",
          "code": "// Worker-Function 매핑 검증 테스트 (61개)\n// 파일: __tests__/pyodide/worker-function-mapping.test.ts\n\n// ┌─────────────────────────────────────────────────────────┐\n// │ 검증 항목                    │ 테스트 수 │ 자동 감지   │\n// ├─────────────────────────────────────────────────────────┤\n// │ 1. 함수 존재 여부            │ 38개     │ ✅ Python에 │\n// │    - Python Worker에 함수가 있는지                      │\n// │                                                         │\n// │ 2. Worker 번호               │ 4개      │ ✅ 최적화   │\n// │    - 올바른 Worker를 호출하는지                         │\n// │                                                         │\n// │ 3. 양방향 동기화             │ 2개      │ ✅ 추가/삭제│\n// │    - 서비스 ↔ EXPECTED_MAPPINGS 일치                    │\n// │                                                         │\n// │ 4. 파라미터 시그니처 ⭐NEW   │ 13개     │ ✅ TypeError│\n// │    - 파라미터 이름 일치 (snake_case)                    │\n// │    - 필수 파라미터 개수                                 │\n// │    - 서비스가 보내는 키 vs Python 기대 파라미터         │\n// └─────────────────────────────────────────────────────────┘\n\n// 검증되지 않는 항목 (런타임에서만 확인 가능):\n// - 파라미터 타입 (number[] vs string[])\n// - 실제 Python 함수 실행 결과\n// - 반환값 구조",
          "keywords": [
            "verification",
            "summary",
            "검증",
            "테스트 목록",
            "61개"
          ]
        },
        {
          "name": "상위 계층 참조 (Analysis Flow)",
          "purpose": "Worker가 호출되는 전체 흐름 참조",
          "code": "// Worker는 전체 분석 흐름의 5번째 계층입니다.\n// 전체 흐름을 이해하려면 \"Analysis Flow Architecture\" 카테고리 참조\n\n// UI → Executor → Service → Core → Worker (여기)\n//\n// 상위 계층에서 Worker 호출하는 방법:\n//\n// 1. Executor (statistical-executor.ts)\n//    const stats = await pyodideStats.descriptiveStats(values)\n//\n// 2. Service (pyodide-statistics.ts)\n//    return this.core.callWorkerMethod(1, 'descriptive_stats', { data })\n//\n// 3. Core (pyodide-core.service.ts)\n//    await this.ensureWorker1Loaded()\n//    const result = this.pyodide.runPythonAsync(`descriptive_stats(**params)`)\n//\n// 4. Worker (worker1-descriptive.py)\n//    def descriptive_stats(data):\n//        return { 'mean': np.mean(data), 'std': np.std(data), ... }",
          "keywords": [
            "cross-reference",
            "상위 계층",
            "Analysis Flow"
          ]
        }
      ]
    },
    {
      "name": "Analysis Flow Architecture",
      "description": "통계 분석 실행 흐름 전체 아키텍처 (UI → Executor → Service → Worker)",
      "patterns": [
        {
          "name": "전체 분석 흐름 (End-to-End Flow)",
          "purpose": "UI 컴포넌트부터 Python Worker까지 전체 데이터 흐름 이해",
          "code": "// === 통계 분석 실행 흐름 (5계층) ===\n//\n// ┌─────────────────────────────────────────────────────────────────┐\n// │ 1. UI Layer (React Components)                                  │\n// │    app/(dashboard)/methods/t-test/page.tsx                     │\n// │    └─ useStatisticsPage() hook 사용                            │\n// │    └─ handleAnalyze() → StatisticalExecutor.executeMethod()    │\n// └─────────────────────────────────────────────────────────────────┘\n//                              ↓\n// ┌─────────────────────────────────────────────────────────────────┐\n// │ 2. Executor Layer (비즈니스 로직)                               │\n// │    lib/services/statistical-executor.ts                        │\n// │    └─ executeMethod(method, data, variables)                   │\n// │    └─ prepareData() → 변수 추출 및 그룹화                       │\n// │    └─ executeTTest() / executeANOVA() 등 카테고리별 분기        │\n// └─────────────────────────────────────────────────────────────────┘\n//                              ↓\n// ┌─────────────────────────────────────────────────────────────────┐\n// │ 3. Service Layer (Python 호출 래퍼)                             │\n// │    lib/services/pyodide-statistics.ts                          │\n// │    └─ pyodideStats.tTest() / .anova() / .correlation()         │\n// │    └─ 내부적으로 PyodideCoreService.callWorkerMethod() 호출     │\n// └─────────────────────────────────────────────────────────────────┘\n//                              ↓\n// ┌─────────────────────────────────────────────────────────────────┐\n// │ 4. Core Service Layer (Worker 관리)                             │\n// │    lib/services/pyodide/core/pyodide-core.service.ts           │\n// │    └─ callWorkerMethod<T>(workerNum, funcName, params)         │\n// │    └─ ensureWorker1/2/3/4Loaded() → 필요 시 Worker 로딩         │\n// │    └─ Python 코드 실행 및 결과 파싱                             │\n// └─────────────────────────────────────────────────────────────────┘\n//                              ↓\n// ┌─────────────────────────────────────────────────────────────────┐\n// │ 5. Python Worker Layer (실제 계산)                              │\n// │    public/workers/python/worker1~4-*.py                        │\n// │    └─ def t_test_two_sample(group1, group2, ...)               │\n// │    └─ SciPy/statsmodels/scikit-learn 사용                      │\n// │    └─ JSON 결과 반환                                            │\n// └─────────────────────────────────────────────────────────────────┘",
          "keywords": [
            "architecture",
            "flow",
            "5-layer",
            "전체 흐름",
            "아키텍처"
          ]
        },
        {
          "name": "Executor 계층 상세",
          "purpose": "StatisticalExecutor의 역할과 카테고리별 분기 이해",
          "code": "// === StatisticalExecutor ===\n// 파일: lib/services/statistical-executor.ts\n// 역할: UI와 Python Worker 사이의 중간 계층 (비즈니스 로직)\n\nclass StatisticalExecutor {\n  // Singleton 패턴\n  static getInstance(): StatisticalExecutor\n\n  // 메인 실행 메서드\n  async executeMethod(\n    method: StatisticalMethod,    // 분석 메서드 정보 (id, name, category)\n    data: any[],                  // 원본 데이터 (업로드된 행 배열)\n    variables: {                  // 변수 역할 매핑\n      dependent?: string[]        // 종속변수\n      independent?: string[]      // 독립변수\n      group?: string              // 그룹변수\n      time?: string               // 시간변수\n      covariate?: string[]        // 공변량 (ANCOVA)\n      within?: string[]           // 피험자내 요인 (반복측정)\n      between?: string[]          // 피험자간 요인 (혼합모형)\n    }\n  ): Promise<AnalysisResult>\n\n  // 카테고리별 분기 (switch-case)\n  switch (method.category) {\n    case 'descriptive':   → executeDescriptive()\n    case 't-test':        → executeTTest()\n    case 'anova':         → executeANOVA()\n    case 'regression':    → executeRegression()\n    case 'correlation':   → executeCorrelation()\n    case 'nonparametric': → executeNonparametric()\n    case 'chi-square':    → executeChiSquare()\n    case 'pca':           → executeMultivariate()\n    case 'timeseries':    → executeTimeSeries()\n    case 'psychometrics': → executeReliability()\n    case 'survival':      → executeSurvival()\n  }\n}\n\n// 데이터 준비 (prepareData)\n// - 종속/독립변수 추출 → arrays.dependent, arrays.independent\n// - 그룹변수로 데이터 분할 → arrays.byGroup\n// - 공변량/피험자내/피험자간 요인 추출",
          "keywords": [
            "Executor",
            "executeMethod",
            "prepareData",
            "category",
            "switch"
          ]
        },
        {
          "name": "Service 계층 (pyodide-statistics.ts)",
          "purpose": "Python Worker 호출 래퍼 레이어 이해",
          "code": "// === pyodide-statistics.ts ===\n// 파일: lib/services/pyodide-statistics.ts\n// 역할: TypeScript에서 Python 함수를 호출하기 위한 래퍼\n\n// ⚠️ 주의사항 (파일 상단 주석)\n// - 새 메서드를 이 파일에 직접 구현하지 말 것!\n// - Python Worker 파일에 함수 추가 후 래퍼만 추가\n\n// 예시: tTest 메서드\nasync tTest(group1: number[], group2: number[], options?) {\n  // 내부적으로 PyodideCoreService 호출\n  return this.core.callWorkerMethod<StatisticsResult>(\n    2,                    // Worker 2 (hypothesis)\n    't_test_two_sample',  // Python 함수명\n    { group1, group2, equal_var: options?.equalVar }\n  )\n}\n\n// pyodideStats 싱글톤 인스턴스\nexport const pyodideStats = PyodideStatistics.getInstance()\n\n// 사용 예시 (Executor에서)\nconst result = await pyodideStats.tTest(group1, group2, { paired: false })\nconst stats = await pyodideStats.descriptiveStats(values)\nconst anova = await pyodideStats.anova(groups, { type: 'one-way' })",
          "keywords": [
            "pyodide-statistics",
            "wrapper",
            "래퍼",
            "pyodideStats"
          ]
        },
        {
          "name": "PyodideCoreService (Worker 관리)",
          "purpose": "Python Worker 로딩 및 호출 메커니즘 이해",
          "code": "// === PyodideCoreService ===\n// 파일: lib/services/pyodide/core/pyodide-core.service.ts\n// 역할: Pyodide 인스턴스 관리 + Worker 로딩 + 메서드 호출\n\nclass PyodideCoreService {\n  // Singleton 패턴\n  private static instance: PyodideCoreService\n\n  // 핵심 메서드: Worker 함수 호출\n  async callWorkerMethod<T>(\n    workerNum: number,           // Worker 번호 (1-4)\n    funcName: string,            // Python 함수명 (snake_case)\n    params: Record<string, any>  // 파라미터 객체\n  ): Promise<T> {\n    // 1. Worker 로딩 확인\n    await this.ensureWorkerLoaded(workerNum)\n\n    // 2. Python 함수 호출\n    const pythonCode = `\n      import json\n      result = ${funcName}(**${JSON.stringify(params)})\n      json.dumps(result)\n    `\n\n    // 3. 결과 파싱 및 반환\n    const result = await this.pyodide.runPythonAsync(pythonCode)\n    return JSON.parse(result) as T\n  }\n\n  // Worker 로딩 (Lazy Loading)\n  private async ensureWorkerLoaded(workerNum: number) {\n    if (this.loadedWorkers.has(workerNum)) return\n\n    const workerCode = await fetch(`/workers/python/worker${workerNum}-*.py`)\n    await this.pyodide.runPythonAsync(workerCode)\n    this.loadedWorkers.add(workerNum)\n  }\n}\n\n// Worker 파일 구성\n// Worker 1: scipy only      (worker1-descriptive.py)      ~2초\n// Worker 2: statsmodels     (worker2-hypothesis.py)       ~3초\n// Worker 3: scikit-learn    (worker3-nonparametric.py)    ~8초\n// Worker 4: scikit-learn    (worker4-regression.py)       ~8초",
          "keywords": [
            "PyodideCoreService",
            "callWorkerMethod",
            "Worker",
            "Lazy Loading"
          ]
        },
        {
          "name": "Python Worker 파일 구조",
          "purpose": "Python Worker 파일의 함수 구조 이해",
          "code": "// === Python Worker 파일 ===\n// 위치: public/workers/python/worker*.py\n\n# worker2-hypothesis.py 예시\nimport numpy as np\nfrom scipy import stats\n\ndef t_test_two_sample(group1, group2, equal_var=True, alternative='two-sided'):\n    \"\"\"\n    독립표본 t-검정 (Two-sample t-test)\n\n    Parameters:\n    -----------\n    group1 : list[float]\n        첫 번째 그룹 데이터\n    group2 : list[float]\n        두 번째 그룹 데이터\n    equal_var : bool\n        등분산 가정 (True: Student's t, False: Welch's t)\n    alternative : str\n        대립가설 방향 ('two-sided', 'less', 'greater')\n\n    Returns:\n    --------\n    dict\n        {\n            't_statistic': float,\n            'p_value': float,\n            'df': float,\n            'mean1': float,\n            'mean2': float,\n            'cohen_d': float\n        }\n    \"\"\"\n    arr1 = np.array(group1)\n    arr2 = np.array(group2)\n\n    result = stats.ttest_ind(arr1, arr2, equal_var=equal_var, alternative=alternative)\n\n    # Cohen's d 계산\n    pooled_std = np.sqrt(((len(arr1)-1)*arr1.std(ddof=1)**2 +\n                          (len(arr2)-1)*arr2.std(ddof=1)**2) /\n                         (len(arr1) + len(arr2) - 2))\n    cohen_d = (arr1.mean() - arr2.mean()) / pooled_std\n\n    return {\n        't_statistic': float(result.statistic),\n        'p_value': float(result.pvalue),\n        'df': float(len(arr1) + len(arr2) - 2),\n        'mean1': float(arr1.mean()),\n        'mean2': float(arr2.mean()),\n        'cohen_d': float(cohen_d)\n    }\n\n# 함수명 규칙: snake_case\n# 파라미터: snake_case\n# 반환값: dict → JSON 직렬화",
          "keywords": [
            "Python Worker",
            "snake_case",
            "SciPy",
            "statsmodels"
          ]
        },
        {
          "name": "BaseExecutor (공통 유틸리티)",
          "purpose": "Executor 공통 기능 (데이터 추출, 에러 처리, 해석)",
          "code": "// === BaseExecutor ===\n// 파일: lib/services/executors/base-executor.ts\n// 역할: 모든 Executor의 공통 기능 제공\n\nabstract class BaseExecutor {\n  // 공통 유틸리티\n\n  // 1. p-value 해석\n  protected interpretPValue(pvalue: number): string {\n    if (pvalue < 0.001) return '매우 강한 통계적 유의성 (p < 0.001)'\n    if (pvalue < 0.01)  return '강한 통계적 유의성 (p < 0.01)'\n    if (pvalue < 0.05)  return '통계적으로 유의 (p < 0.05)'\n    if (pvalue < 0.1)   return '약한 통계적 유의성 (p < 0.1)'\n    return '통계적으로 유의하지 않음 (p ≥ 0.05)'\n  }\n\n  // 2. 효과크기 해석\n  protected interpretEffectSize(d: number, type: 'cohen' | 'eta' | 'omega'): string {\n    if (type === 'cohen') {\n      if (d < 0.2) return '무시할 수준'\n      if (d < 0.5) return '작은 효과'\n      if (d < 0.8) return '중간 효과'\n      return '큰 효과'\n    }\n    // eta-squared, omega-squared\n    if (d < 0.01) return '무시할 수준'\n    if (d < 0.06) return '작은 효과'\n    if (d < 0.14) return '중간 효과'\n    return '큰 효과'\n  }\n\n  // 3. 수치형 데이터 추출 (객체 배열 → 숫자 배열)\n  protected extractNumericSeries(data: unknown[], options?: unknown): number[] {\n    // - 이미 숫자 배열이면 그대로 반환\n    // - 객체 배열이면 variables 옵션에서 컬럼명 추출\n    // - null/undefined/''/NaN 필터링\n  }\n\n  // 4. 메타데이터 생성\n  protected createMetadata(method: string, dataSize: number, startTime: number)\n\n  // 5. 에러 처리\n  protected handleError(error: unknown, method: string): AnalysisResult\n\n  // 추상 메서드 (각 Executor가 구현)\n  abstract execute(data: unknown[], options?: unknown): Promise<AnalysisResult>\n}",
          "keywords": [
            "BaseExecutor",
            "interpretPValue",
            "extractNumericSeries",
            "공통 유틸"
          ]
        },
        {
          "name": "AnalysisResult 결과 타입",
          "purpose": "통계 분석 결과의 표준 데이터 구조",
          "code": "// === StatisticalExecutorResult (AnalysisResult) ===\n// 파일: lib/services/statistical-executor.ts\n\ninterface StatisticalExecutorResult {\n  // 1. 메타데이터\n  metadata: {\n    method: string           // 메서드 ID (예: 'two-sample-t')\n    methodName: string       // 표시명 (예: '독립표본 t-검정')\n    timestamp: string        // ISO 8601 (예: '2025-11-27T12:00:00Z')\n    duration: number         // 실행 시간 (초)\n    dataInfo: {\n      totalN: number         // 총 표본 수\n      missingRemoved: number // 제거된 결측값 수\n      groups?: number        // 그룹 수 (해당 시)\n    }\n  }\n\n  // 2. 주 결과\n  mainResults: {\n    statistic: number        // 검정통계량 (t, F, χ², r 등)\n    pvalue: number           // 유의확률\n    df?: number              // 자유도\n    significant: boolean     // 유의 여부 (p < 0.05)\n    interpretation?: string  // 결과 해석 문장\n  }\n\n  // 3. 부가 정보\n  additionalInfo: {\n    effectSize?: {           // 효과크기\n      type: string           // \"Cohen's d\", \"eta-squared\", \"R²\" 등\n      value: number\n      interpretation: string // \"작은 효과\", \"중간 효과\" 등\n    }\n    confidenceInterval?: {   // 신뢰구간\n      level: number          // 95\n      lower: number\n      upper: number\n    }\n    assumptions?: {          // 가정 검정 결과\n      passed: boolean\n      details: any[]\n    }\n    postHoc?: any            // 사후검정 결과 (ANOVA)\n  }\n\n  // 4. 시각화 데이터\n  visualizationData?: {\n    type: string             // 'boxplot', 'histogram', 'scatter' 등\n    data: any                // 차트 렌더링용 데이터\n  }\n\n  // 5. 원시 결과 (디버깅용)\n  rawResults?: any           // Python Worker 원본 반환값\n}",
          "keywords": [
            "AnalysisResult",
            "StatisticalExecutorResult",
            "결과 타입",
            "mainResults"
          ]
        }
      ]
    }
  ],
  "bestPractices": [
    {
      "title": "AAA 패턴 (Arrange-Act-Assert)",
      "description": "테스트를 3단계로 구조화하여 가독성 향상",
      "example": "it('버튼 클릭 시 카운터가 증가해야 함', () => {\n  // Arrange (준비)\n  const handleClick = jest.fn();\n  render(<Counter onClick={handleClick} />);\n  \n  // Act (실행)\n  fireEvent.click(screen.getByRole('button'));\n  \n  // Assert (검증)\n  expect(handleClick).toHaveBeenCalledTimes(1);\n  expect(screen.getByText('Count: 1')).toBeInTheDocument();\n});"
    },
    {
      "title": "테스트 이름 작성 규칙",
      "description": "명확하고 설명적인 테스트 이름 사용",
      "example": "// ❌ Bad\nit('works', () => { ... });\nit('test1', () => { ... });\n\n// ✅ Good\nit('버튼 클릭 시 모달이 열려야 함', () => { ... });\nit('잘못된 이메일 입력 시 에러 메시지가 표시되어야 함', () => { ... });\nit('로딩 중에는 스피너가 표시되고 버튼이 비활성화되어야 함', () => { ... });"
    },
    {
      "title": "단일 책임 원칙 (Single Responsibility)",
      "description": "하나의 테스트는 하나의 동작만 검증",
      "example": "// ❌ Bad: 여러 동작을 한 테스트에서 검증\nit('폼이 정상 동작해야 함', () => {\n  // 렌더링 검증\n  // 입력 검증\n  // 제출 검증\n  // 에러 검증\n});\n\n// ✅ Good: 각 동작을 별도 테스트로 분리\nit('폼이 정상 렌더링되어야 함', () => { ... });\nit('입력 필드가 정상 동작해야 함', () => { ... });\nit('제출 시 데이터가 전송되어야 함', () => { ... });\nit('검증 실패 시 에러 메시지가 표시되어야 함', () => { ... });"
    },
    {
      "title": "비동기 테스트 처리",
      "description": "waitFor, findBy를 사용하여 비동기 동작 대기",
      "example": "// ❌ Bad: 비동기 대기 없이 즉시 검증\nit('데이터 로딩 후 표시', () => {\n  render(<MyComponent />);\n  expect(screen.getByText('Data')).toBeInTheDocument();  // 실패!\n});\n\n// ✅ Good: waitFor로 비동기 대기\nit('데이터 로딩 후 표시', async () => {\n  render(<MyComponent />);\n  \n  await waitFor(() => {\n    expect(screen.getByText('Data')).toBeInTheDocument();\n  });\n});\n\n// ✅ Better: findBy 사용 (자동 대기)\nit('데이터 로딩 후 표시', async () => {\n  render(<MyComponent />);\n  \n  const data = await screen.findByText('Data');\n  expect(data).toBeInTheDocument();\n});"
    }
  ],
  "commonErrors": [
    {
      "error": "\"not wrapped in act(...)\" 경고",
      "cause": "React 상태 업데이트가 테스트 외부에서 발생",
      "solution": "waitFor를 사용하여 상태 업데이트 대기:\n\nawait waitFor(() => {\n  expect(screen.getByText('Updated')).toBeInTheDocument();\n});"
    },
    {
      "error": "\"Unable to find element\" 에러",
      "cause": "요소가 렌더링되지 않았거나 잘못된 쿼리 사용",
      "solution": "1. screen.debug()로 현재 DOM 확인\n2. getByRole, getByText 등 올바른 쿼리 사용\n3. 비동기인 경우 findBy 또는 waitFor 사용"
    },
    {
      "error": "\"Cannot read property of undefined\" 에러",
      "cause": "모킹되지 않은 의존성 호출",
      "solution": "jest.mock()으로 의존성 모킹:\n\njest.mock('@/lib/api');\nconst mockFetchData = fetchData as jest.MockedFunction<typeof fetchData>;\nmockFetchData.mockResolvedValue([]);"
    }
  ]
}