{
  "id": "test-snippets",
  "version": "1.6.0",
  "lastUpdated": "2025-11-27",
  "sources": [
    "statistical-platform/__tests__/",
    "statistical-platform/jest.config.js"
  ],
  "categories": [
    {
      "name": "React Component Tests",
      "description": "React 컴포넌트 테스트 패턴",
      "patterns": [
        {
          "name": "기본 렌더링 테스트",
          "purpose": "컴포넌트가 정상적으로 렌더링되는지 확인",
          "code": "import { render, screen } from '@testing-library/react';\nimport { MyComponent } from '@/components/MyComponent';\n\ndescribe('MyComponent', () => {\n  it('기본 렌더링이 정상적으로 동작해야 함', () => {\n    render(<MyComponent />);\n    \n    expect(screen.getByText('Hello')).toBeInTheDocument();\n    expect(screen.getByRole('button')).toBeInTheDocument();\n  });\n});",
          "keywords": [
            "render",
            "screen",
            "getByText",
            "toBeInTheDocument"
          ]
        },
        {
          "name": "이벤트 핸들링 테스트",
          "purpose": "사용자 이벤트(클릭, 입력 등)가 정상 동작하는지 확인",
          "code": "import { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport { MyComponent } from '@/components/MyComponent';\n\ndescribe('MyComponent 이벤트', () => {\n  it('버튼 클릭 시 콜백이 호출되어야 함', async () => {\n    const handleClick = jest.fn();\n    render(<MyComponent onClick={handleClick} />);\n    \n    fireEvent.click(screen.getByRole('button'));\n    \n    await waitFor(() => {\n      expect(handleClick).toHaveBeenCalledTimes(1);\n    });\n  });\n  \n  it('입력 필드에 텍스트 입력 시 상태가 업데이트되어야 함', () => {\n    render(<MyComponent />);\n    \n    const input = screen.getByPlaceholderText('Enter text');\n    fireEvent.change(input, { target: { value: 'Hello' } });\n    \n    expect(input).toHaveValue('Hello');\n  });\n});",
          "keywords": [
            "fireEvent",
            "click",
            "change",
            "waitFor"
          ]
        },
        {
          "name": "비동기 데이터 로딩 테스트",
          "purpose": "비동기 데이터 로딩 및 로딩 상태 확인",
          "code": "import { render, screen, waitFor } from '@testing-library/react';\nimport { MyComponent } from '@/components/MyComponent';\nimport { fetchData } from '@/lib/api';\n\njest.mock('@/lib/api');\nconst mockFetchData = fetchData as jest.MockedFunction<typeof fetchData>;\n\ndescribe('MyComponent 비동기', () => {\n  it('로딩 중에는 스피너가 표시되어야 함', async () => {\n    mockFetchData.mockImplementation(() => \n      new Promise(resolve => setTimeout(() => resolve([]), 1000))\n    );\n    \n    render(<MyComponent />);\n    \n    // 로딩 스피너 확인\n    expect(screen.getByRole('status')).toBeInTheDocument();\n    \n    // 데이터 로딩 완료 후\n    await waitFor(() => {\n      expect(screen.queryByRole('status')).not.toBeInTheDocument();\n    });\n  });\n  \n  it('데이터 로딩 실패 시 에러 메시지가 표시되어야 함', async () => {\n    mockFetchData.mockRejectedValue(new Error('Failed to fetch'));\n    \n    render(<MyComponent />);\n    \n    await waitFor(() => {\n      expect(screen.getByText(/Failed to fetch/)).toBeInTheDocument();\n    });\n  });\n});",
          "keywords": [
            "mock",
            "mockResolvedValue",
            "mockRejectedValue",
            "waitFor"
          ]
        }
      ]
    },
    {
      "name": "Schema Validation Tests",
      "description": "스키마 검증 테스트 패턴 (통계 결과 일관성 보장)",
      "patterns": [
        {
          "name": "카테고리별 필수 필드 검증",
          "purpose": "통계 방법별 필수 필드 존재 여부 확인",
          "code": "import { describe, it, expect } from '@jest/globals';\nimport { validateResultSchema, getCategoryForMethod } from '@/lib/validation/result-schema-validator';\nimport type { AnalysisResult } from '@/types/smart-flow';\n\ndescribe('Result Schema Validator', () => {\n  it('should pass when all required fields exist', () => {\n    const result: AnalysisResult = {\n      method: 'Independent t-test',\n      statistic: 2.5,\n      pValue: 0.05,\n      interpretation: 'Significant difference found'\n    };\n\n    const validation = validateResultSchema(result, 't-test');\n\n    expect(validation.valid).toBe(true);\n    expect(validation.missing).toHaveLength(0);\n    expect(validation.category).toBe('comparison');\n  });\n\n  it('should fail when required field is missing', () => {\n    const result = {\n      method: 'regression',\n      statistic: 15.3,\n      pValue: 0.001,\n      interpretation: 'Model fit'\n      // missing additional.rSquared\n    } as AnalysisResult;\n\n    const validation = validateResultSchema(result, 'regression');\n\n    expect(validation.valid).toBe(false);\n    expect(validation.missing).toContain('additional.rSquared');\n  });\n});",
          "keywords": [
            "schema validation",
            "required fields",
            "category mapping"
          ]
        },
        {
          "name": "Method ID 정규화 검증",
          "purpose": "다양한 method ID 형식이 올바른 카테고리로 매핑되는지 확인",
          "code": "describe('Method ID Normalization', () => {\n  it('should map executor-facing IDs correctly', () => {\n    // executor에서 사용하는 짧은 ID들\n    expect(getCategoryForMethod('simple')).toBe('regression');\n    expect(getCategoryForMethod('multiple')).toBe('regression');\n    expect(getCategoryForMethod('logistic')).toBe('regression');\n  });\n\n  it('should normalize method IDs with spaces', () => {\n    expect(getCategoryForMethod('t test')).toBe('comparison');\n    expect(getCategoryForMethod('chi square')).toBe('goodnessOfFit');\n  });\n\n  it('should handle case insensitive method IDs', () => {\n    expect(getCategoryForMethod('T-TEST')).toBe('comparison');\n    expect(getCategoryForMethod('ANOVA')).toBe('comparison');\n  });\n\n  it('should default to comparison for unknown methods', () => {\n    expect(getCategoryForMethod('unknown-method')).toBe('comparison');\n  });\n});",
          "keywords": [
            "method ID",
            "normalization",
            "case insensitive"
          ]
        },
        {
          "name": "배치 검증 테스트",
          "purpose": "여러 결과를 동시에 검증하고 실패한 method 식별",
          "code": "import { validateBatch } from '@/lib/validation/result-schema-validator';\n\ndescribe('Batch Validation', () => {\n  it('should validate multiple results at once', () => {\n    const results = [\n      { methodId: 't-test', result: { method: 't-test', statistic: 2.5, pValue: 0.05, interpretation: 'Significant' } },\n      { methodId: 'regression', result: { method: 'regression', statistic: 15.3, pValue: 0.001, interpretation: 'Model fit' } }\n    ];\n\n    const batch = validateBatch(results);\n\n    expect(batch.allValid).toBe(false);\n    expect(batch.failedMethods).toContain('regression');\n    expect(batch.failedMethods).not.toContain('t-test');\n  });\n});",
          "keywords": [
            "batch validation",
            "multiple results",
            "failed methods"
          ]
        }
      ]
    },
    {
      "name": "Integration Tests",
      "description": "통합 테스트 패턴 (프론트-백엔드 연결)",
      "patterns": [
        {
          "name": "데이터 구조 검증",
          "purpose": "프론트 → Python Worker 데이터 구조 일치 확인",
          "code": "import { describe, it, expect } from '@jest/globals';\n\ndescribe('ANOVA Integration Tests', () => {\n  it('데이터 구조가 Python Worker와 일치해야 함', () => {\n    // 프론트에서 준비하는 데이터 구조\n    const dataValues = [10, 12, 14, 16, 18, 20];\n    const factor1Values = ['A', 'A', 'B', 'B', 'C', 'C'];\n    \n    // 검증: 배열 길이 일치\n    expect(dataValues.length).toBe(factor1Values.length);\n    \n    // 검증: 최소 데이터 (4개 이상)\n    expect(dataValues.length).toBeGreaterThanOrEqual(4);\n    \n    // 검증: 데이터 타입\n    expect(Array.isArray(dataValues)).toBe(true);\n    expect(dataValues.every(v => typeof v === 'number')).toBe(true);\n  });\n});",
          "keywords": [
            "integration",
            "data validation",
            "Python Worker"
          ]
        },
        {
          "name": "Python Worker 파라미터 검증",
          "purpose": "Python Worker 호출 시 파라미터 형식 확인",
          "code": "import { describe, it, expect } from '@jest/globals';\n\ndescribe('Python Worker 파라미터', () => {\n  it('파라미터가 올바른 형식이어야 함', () => {\n    const params = {\n      data_values: [10, 12, 14, 16],\n      factor1_values: ['A', 'A', 'B', 'B'],\n      factor2_values: ['Low', 'High', 'Low', 'High']\n    };\n    \n    // 검증: 필수 키 존재\n    expect(params).toHaveProperty('data_values');\n    expect(params).toHaveProperty('factor1_values');\n    expect(params).toHaveProperty('factor2_values');\n    \n    // 검증: snake_case 사용 (Python 규약)\n    expect(Object.keys(params)).toEqual([\n      'data_values',\n      'factor1_values',\n      'factor2_values'\n    ]);\n  });\n});",
          "keywords": [
            "parameters",
            "snake_case",
            "validation"
          ]
        },
        {
          "name": "Python Worker 반환값 검증",
          "purpose": "Python Worker 반환값이 TypeScript 타입과 일치하는지 확인",
          "code": "import { describe, it, expect } from '@jest/globals';\n\ndescribe('Python Worker 반환값', () => {\n  it('반환 타입이 TwoWayANOVAResult와 일치해야 함', () => {\n    // Python Worker 반환 예상 구조\n    const mockResult = {\n      factor1: {\n        fStatistic: 5.2,\n        pValue: 0.032,\n        df: 1\n      },\n      factor2: {\n        fStatistic: 3.8,\n        pValue: 0.067,\n        df: 1\n      },\n      interaction: {\n        fStatistic: 2.1,\n        pValue: 0.165,\n        df: 1\n      },\n      residual: {\n        df: 8\n      }\n    };\n    \n    // 검증: 필수 필드 존재\n    expect(mockResult).toHaveProperty('factor1');\n    expect(mockResult).toHaveProperty('factor2');\n    expect(mockResult).toHaveProperty('interaction');\n    expect(mockResult).toHaveProperty('residual');\n    \n    // 검증: 숫자 타입\n    expect(typeof mockResult.factor1.fStatistic).toBe('number');\n    expect(typeof mockResult.factor1.pValue).toBe('number');\n  });\n});",
          "keywords": [
            "return type",
            "validation",
            "TypeScript"
          ]
        }
      ]
    },
    {
      "name": "Mock Patterns",
      "description": "모킹 패턴 (외부 의존성 격리)",
      "patterns": [
        {
          "name": "함수 모킹",
          "purpose": "외부 함수를 모킹하여 테스트 격리",
          "code": "import { myFunction } from '@/lib/utils';\n\njest.mock('@/lib/utils');\nconst mockMyFunction = myFunction as jest.MockedFunction<typeof myFunction>;\n\ndescribe('함수 모킹', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n  \n  it('함수가 호출되어야 함', () => {\n    mockMyFunction.mockReturnValue(42);\n    \n    const result = mockMyFunction(10);\n    \n    expect(mockMyFunction).toHaveBeenCalledWith(10);\n    expect(result).toBe(42);\n  });\n  \n  it('비동기 함수 모킹', async () => {\n    mockMyFunction.mockResolvedValue({ data: 'success' });\n    \n    const result = await mockMyFunction();\n    \n    expect(result).toEqual({ data: 'success' });\n  });\n});",
          "keywords": [
            "jest.mock",
            "mockReturnValue",
            "mockResolvedValue"
          ]
        },
        {
          "name": "모듈 모킹",
          "purpose": "전체 모듈을 모킹하여 복잡한 의존성 제거",
          "code": "// Mock markdown dependencies (ESM modules)\njest.mock('remark-gfm', () => ({}));\njest.mock('remark-breaks', () => ({}));\njest.mock('react-markdown', () => ({\n  __esModule: true,\n  default: ({ children }: { children: string }) => <div>{children}</div>\n}));\n\n// Mock 컴포넌트\njest.mock('@/components/rag/chat-sources-display', () => ({\n  ChatSourcesDisplay: () => <div data-testid=\"chat-sources\">Sources</div>\n}));\n\ndescribe('모듈 모킹', () => {\n  it('모킹된 컴포넌트가 렌더링되어야 함', () => {\n    render(<MyComponent />);\n    \n    expect(screen.getByTestId('chat-sources')).toBeInTheDocument();\n  });\n});",
          "keywords": [
            "jest.mock",
            "__esModule",
            "module mocking"
          ]
        },
        {
          "name": "window 객체 모킹",
          "purpose": "브라우저 API (window.open, localStorage 등) 모킹",
          "code": "const mockWindowOpen = jest.fn();\nconst mockLocalStorage = {\n  getItem: jest.fn(),\n  setItem: jest.fn(),\n  removeItem: jest.fn(),\n  clear: jest.fn()\n};\n\ndescribe('window 객체 모킹', () => {\n  beforeEach(() => {\n    window.open = mockWindowOpen;\n    Object.defineProperty(window, 'localStorage', {\n      value: mockLocalStorage,\n      writable: true\n    });\n  });\n  \n  it('window.open이 호출되어야 함', () => {\n    render(<MyComponent />);\n    \n    fireEvent.click(screen.getByText('새 창 열기'));\n    \n    expect(mockWindowOpen).toHaveBeenCalledWith('/chatbot', '_blank');\n  });\n  \n  it('localStorage가 호출되어야 함', () => {\n    mockLocalStorage.getItem.mockReturnValue('saved-value');\n    \n    render(<MyComponent />);\n    \n    expect(mockLocalStorage.getItem).toHaveBeenCalledWith('key');\n  });\n});",
          "keywords": [
            "window.open",
            "localStorage",
            "browser API"
          ]
        },
        {
          "name": "IndexedDB graceful degradation",
          "purpose": "브라우저 호환성 (Safari/Firefox에서 미지원 API 처리)",
          "code": "describe('IndexedDB cleanup graceful degradation', () => {\n  it('indexedDB.databases가 undefined일 때도 에러 없이 처리되어야 함', async () => {\n    // Safari/Firefox 시뮬레이션: databases 메서드가 없음\n    const mockIndexedDB = {\n      deleteDatabase: jest.fn(),\n      // databases 메서드 없음 (undefined)\n    };\n\n    Object.defineProperty(window, 'indexedDB', {\n      value: mockIndexedDB,\n      writable: true,\n    });\n\n    const cleanupIndexedDB = async () => {\n      try {\n        if (typeof window.indexedDB.databases === 'function') {\n          const databases = await window.indexedDB.databases();\n          for (const db of databases) {\n            if (db.name) {\n              window.indexedDB.deleteDatabase(db.name);\n            }\n          }\n        }\n      } catch (e) {\n        console.warn('[Settings] IndexedDB cleanup failed:', e);\n      }\n    };\n\n    await expect(cleanupIndexedDB()).resolves.not.toThrow();\n    expect(mockIndexedDB.deleteDatabase).not.toHaveBeenCalled();\n  });\n\n  it('indexedDB.databases가 에러를 던져도 graceful하게 처리되어야 함', async () => {\n    const consoleWarnSpy = jest.spyOn(console, 'warn').mockImplementation();\n    const mockIndexedDB = {\n      databases: jest.fn().mockRejectedValue(new Error('Not supported')),\n      deleteDatabase: jest.fn(),\n    };\n\n    Object.defineProperty(window, 'indexedDB', {\n      value: mockIndexedDB,\n      writable: true,\n    });\n\n    // ... cleanup 로직 ...\n    await expect(cleanupIndexedDB()).resolves.not.toThrow();\n    expect(consoleWarnSpy).toHaveBeenCalled();\n    consoleWarnSpy.mockRestore();\n  });\n});",
          "keywords": [
            "indexedDB",
            "browser compatibility",
            "feature detection",
            "graceful degradation",
            "Safari",
            "Firefox"
          ]
        }
      ]
    },
    {
      "name": "Regression Tests",
      "description": "회귀 테스트 패턴 (버그 재발 방지)",
      "patterns": [
        {
          "name": "Method Matching Regression",
          "purpose": "메서드명 매칭 로직의 버그 수정 검증",
          "code": "import { getInterpretation } from '@/lib/interpretation/engine';\nimport type { AnalysisResult } from '@/types/smart-flow';\n\ndescribe('T-Test Method Matching Regression Tests', () => {\n  describe('Independent Samples t-test - should match', () => {\n    it('Independent t-test (basic)', () => {\n      const results: AnalysisResult = {\n        method: 'Independent t-test',\n        pValue: 0.03,\n        statistic: 2.5,\n        interpretation: ''\n      };\n\n      const interpretation = getInterpretation(results);\n\n      expect(interpretation).not.toBeNull();\n      expect(interpretation?.title).toContain('t');\n    });\n  });\n\n  describe('Non-t-test methods with \"independent\" - should NOT match t-test', () => {\n    it('Independent KS Test should NOT match t-test', () => {\n      const results: AnalysisResult = {\n        method: 'Independent KS Test',\n        pValue: 0.02,\n        statistic: 0.35,\n        interpretation: ''\n      };\n\n      const interpretation = getInterpretation(results);\n\n      // Should return null or match a different interpretation (not t-test)\n      if (interpretation !== null) {\n        expect(interpretation.title).not.toContain('t');\n      }\n    });\n  });\n});",
          "keywords": [
            "regression",
            "method matching",
            "interpretation engine",
            "pattern matching"
          ]
        }
      ]
    },
    {
      "name": "Test Setup & Teardown",
      "description": "테스트 설정 및 정리 패턴",
      "patterns": [
        {
          "name": "beforeEach / afterEach",
          "purpose": "각 테스트 전/후 설정 및 정리",
          "code": "describe('MyComponent', () => {\n  beforeEach(() => {\n    // 각 테스트 전에 실행\n    jest.clearAllMocks();\n    localStorage.clear();\n  });\n  \n  afterEach(() => {\n    // 각 테스트 후에 실행\n    jest.restoreAllMocks();\n  });\n  \n  it('테스트 1', () => {\n    // ...\n  });\n  \n  it('테스트 2', () => {\n    // ...\n  });\n});",
          "keywords": [
            "beforeEach",
            "afterEach",
            "setup",
            "teardown"
          ]
        },
        {
          "name": "beforeAll / afterAll",
          "purpose": "모든 테스트 전/후 한 번만 실행",
          "code": "describe('MyComponent', () => {\n  beforeAll(() => {\n    // 모든 테스트 전에 한 번만 실행\n    console.log('테스트 시작');\n  });\n  \n  afterAll(() => {\n    // 모든 테스트 후에 한 번만 실행\n    console.log('테스트 종료');\n  });\n  \n  it('테스트 1', () => {\n    // ...\n  });\n  \n  it('테스트 2', () => {\n    // ...\n  });\n});",
          "keywords": [
            "beforeAll",
            "afterAll",
            "global setup"
          ]
        },
        {
          "name": "테스트 격리 (Isolation)",
          "purpose": "각 테스트가 독립적으로 실행되도록 보장",
          "code": "describe('격리된 테스트', () => {\n  let mockData: any;\n  \n  beforeEach(() => {\n    // 각 테스트마다 새로운 데이터 생성\n    mockData = {\n      id: Math.random(),\n      name: 'Test',\n      items: []\n    };\n  });\n  \n  it('테스트 1이 mockData를 수정해도', () => {\n    mockData.name = 'Modified';\n    expect(mockData.name).toBe('Modified');\n  });\n  \n  it('테스트 2는 원본 mockData를 받음', () => {\n    // beforeEach로 새로 생성됨\n    expect(mockData.name).toBe('Test');\n  });\n});",
          "keywords": [
            "isolation",
            "independent tests",
            "fresh data"
          ]
        }
      ]
    },
    {
      "name": "Pyodide Worker Tests",
      "description": "Pyodide Worker 매핑 검증 테스트 패턴",
      "patterns": [
        {
          "name": "Worker-Function 매핑 검증",
          "purpose": "TypeScript에서 호출하는 함수가 실제 Python Worker 파일에 존재하는지 검증",
          "code": "extractFunctionsFromWorker(workerNum): Worker 파일에서 def function_name( 패턴으로 함수 추출\n\nEXPECTED_MAPPINGS: { worker: number, function: string, tsMethod: string }[]\n\nit(`${tsMethod}() → Worker ${worker}의 ${pyFunc}() 함수가 존재해야 함`, () => {\n  expect(workerFunctions[worker]).toContain(pyFunc);\n});",
          "keywords": [
            "Worker",
            "Pyodide",
            "function mapping",
            "Python"
          ]
        },
        {
          "name": "양방향 동기화 검증 (Bidirectional Sync)",
          "purpose": "서비스 메서드 추가/삭제 시 EXPECTED_MAPPINGS 업데이트를 강제하여 누락 방지",
          "code": "// 1. 서비스 파일에서 메서드 추출\nfunction extractServiceMethods() {\n  const content = readFileSync(SERVICE_PATH, 'utf8')\n  const pattern = /asyncs+(w+).*callWorkerMethod.*((d),.*['\"]([w_]+)['\"]/g\n  // ... 추출 로직\n}\n\n// 2. 양방향 검증 테스트\nit('서비스의 모든 메서드가 EXPECTED_MAPPINGS에 등록되어 있어야 함', () => {\n  const serviceMethods = extractServiceMethods()\n  const testedMethods = EXPECTED_MAPPINGS.map(m => m.tsMethod)\n  const untestedMethods = serviceMethods.filter(m => !testedMethods.includes(m.tsMethod))\n  \n  if (untestedMethods.length > 0) {\n    throw new Error('EXPECTED_MAPPINGS에 추가하세요: ' + untestedMethods.map(m => m.tsMethod))\n  }\n})\n\nit('EXPECTED_MAPPINGS의 모든 메서드가 서비스에 존재해야 함', () => {\n  // 삭제된 메서드 감지 → EXPECTED_MAPPINGS에서도 제거 강제\n})",
          "keywords": [
            "Bidirectional",
            "Sync",
            "동기화",
            "양방향",
            "EXPECTED_MAPPINGS"
          ]
        }
      ]
    },
    {
      "name": "Pyodide Worker Architecture",
      "description": "Pyodide Worker 매핑 구조 이해 및 관리 방법",
      "patterns": [
        {
          "name": "3계층 매핑 구조 (3-Layer Mapping)",
          "purpose": "TypeScript → Service → Python Worker 호출 흐름 이해",
          "code": "// === 3계층 매핑 구조 ===\n//\n// 1. TypeScript 메서드 (pyodide-core.service.ts)\n//    async twoSampleTTest(group1: number[], group2: number[]): Promise<StatisticsResult>\n//\n// 2. callWorkerMethod 호출 (Worker 번호 + Python 함수명)\n//    return this.callWorkerMethod<StatisticsResult>(2, 't_test_two_sample', { group1, group2 })\n//                                                   ^        ^\n//                                                   |        |\n//                                       Worker 번호(1-4)   Python 함수명\n//\n// 3. Python Worker 실행 (worker2-hypothesis.py)\n//    def t_test_two_sample(group1, group2):\n//        from scipy import stats\n//        return stats.ttest_ind(group1, group2)\n\n// === Worker 구성 ===\n// Worker 1: scipy만 (가벼움) - normality_test, descriptive_stats, outlier_detection\n// Worker 2: scipy + statsmodels (중간) - t-tests, chi-square, correlation\n// Worker 3: scikit-learn (무거움) - nonparametric + ANOVA + post-hoc\n// Worker 4: scikit-learn (무거움) - regression + PCA + factor + cluster",
          "keywords": [
            "3-layer",
            "mapping",
            "callWorkerMethod",
            "Worker"
          ]
        },
        {
          "name": "Worker 선택 최적화",
          "purpose": "가벼운 함수는 Worker 1/2, 무거운 함수는 Worker 3/4 사용",
          "code": "// Worker 로딩 시간 차이 (scikit-learn 여부)\n//\n// Worker 1: scipy only       → ~2초  (기본 통계)\n// Worker 2: scipy+statsmodels → ~3초  (가설 검정)\n// Worker 3: +scikit-learn    → ~8초  (비모수 + ANOVA)\n// Worker 4: +scikit-learn    → ~8초  (회귀 + 고급)\n//\n// 최적화 원칙:\n// - 간단한 통계 (평균, 정규성, 이상치) → Worker 1\n// - 가설 검정 (t-test, chi-square)    → Worker 2\n// - 비모수 + ANOVA                    → Worker 3\n// - 회귀 + 고급 분석                  → Worker 4\n\n// ✅ 올바른 Worker 선택\nawait this.ensureWorker1Loaded()  // scipy만 필요한 함수\nreturn this.callWorkerMethod(1, 'descriptive_stats', { data })\n\n// ❌ 잘못된 Worker 선택 (불필요하게 무거운 Worker 사용)\nawait this.ensureWorker4Loaded()  // scikit-learn 불필요한데 Worker 4 사용\nreturn this.callWorkerMethod(4, 'descriptive_stats', { data })",
          "keywords": [
            "optimization",
            "Worker 선택",
            "scikit-learn",
            "로딩 시간"
          ]
        },
        {
          "name": "함수명 규칙 (snake_case)",
          "purpose": "Python Worker 함수명은 snake_case 사용 필수",
          "code": "// Python Worker 함수명 규칙\n//\n// ✅ 올바른 함수명 (snake_case)\n// def t_test_two_sample(group1, group2):\n// def chi_square_test(observed, expected):\n// def one_way_anova(groups):\n//\n// ❌ 잘못된 함수명\n// def tTestTwoSample()  // camelCase 금지\n// def TwoSampleTTest()  // PascalCase 금지\n// def two-sample-ttest()  // kebab-case 금지\n//\n// TypeScript 메서드명 → Python 함수명 매핑\n// twoSampleTTest()    → t_test_two_sample\n// chiSquareTest()     → chi_square_test\n// oneWayANOVA()       → one_way_anova\n// simpleLinearRegression() → linear_regression",
          "keywords": [
            "snake_case",
            "naming convention",
            "함수명"
          ]
        },
        {
          "name": "매핑 검증 테스트 추가 방법",
          "purpose": "새 함수 추가 시 EXPECTED_MAPPINGS에 등록",
          "code": "// 새 Worker 메서드 추가 시 EXPECTED_MAPPINGS 업데이트 필수!\n// 파일: __tests__/pyodide/worker-function-mapping.test.ts\n\nconst EXPECTED_MAPPINGS = [\n  // ... 기존 매핑 ...\n\n  // 새로 추가하는 함수\n  {\n    worker: 3,                    // Python Worker 번호 (1-4)\n    function: 'dunn_test',        // Python 함수명 (snake_case)\n    tsMethod: 'dunnTestWorker'    // TypeScript 메서드명 (camelCase)\n  },\n]\n\n// 양방향 동기화로 자동 감지:\n// 1. 서비스에 메서드 추가 → 테스트 실패 → EXPECTED_MAPPINGS에 추가\n// 2. 서비스에서 메서드 삭제 → 테스트 실패 → EXPECTED_MAPPINGS에서 제거\n// 3. Python에 함수 없음 → 테스트 실패 → Python Worker에 함수 구현",
          "keywords": [
            "EXPECTED_MAPPINGS",
            "테스트",
            "새 함수 추가"
          ]
        },
        {
          "name": "현재 Worker별 함수 목록",
          "purpose": "2025-11-27 기준 Worker별 함수 배치",
          "code": "// Worker 1 (scipy only - 가벼움)\n// - normality_test       (shapiroWilkTest)\n// - descriptive_stats    (descriptiveStats)\n// - outlier_detection    (outlierDetection)\n// - cronbach_alpha       (cronbachAlpha)\n// - one_sample_proportion_test (oneSampleProportionTest)\n// - bonferroni_correction (performBonferroni)\n\n// Worker 2 (scipy + statsmodels - 중간)\n// - t_test_two_sample    (twoSampleTTest)\n// - t_test_paired        (pairedTTest)\n// - t_test_one_sample    (oneSampleTTest)\n// - z_test               (zTestWorker)\n// - chi_square_test      (chiSquareTest)\n// - binomial_test        (binomialTestWorker)\n// - correlation_test     (correlationTest)\n// - partial_correlation  (partialCorrelationWorker)\n// - levene_test          (leveneTest)\n\n// Worker 3 (scikit-learn - 무거움, 비모수 + ANOVA)\n// - mann_whitney_test, wilcoxon_test, kruskal_wallis_test\n// - friedman_test, sign_test, runs_test, mcnemar_test\n// - cochran_q_test, mood_median_test\n// - one_way_anova, two_way_anova, repeated_measures_anova\n// - ancova, manova\n// - tukey_hsd, scheffe_test, games_howell_test\n\n// Worker 4 (scikit-learn - 무거움, 회귀 + 고급)\n// - linear_regression, multiple_regression, logistic_regression\n// - pca_analysis, factor_analysis, cluster_analysis",
          "keywords": [
            "Worker 목록",
            "함수 배치",
            "현재 상태"
          ]
        }
      ]
    }
  ],
  "bestPractices": [
    {
      "title": "AAA 패턴 (Arrange-Act-Assert)",
      "description": "테스트를 3단계로 구조화하여 가독성 향상",
      "example": "it('버튼 클릭 시 카운터가 증가해야 함', () => {\n  // Arrange (준비)\n  const handleClick = jest.fn();\n  render(<Counter onClick={handleClick} />);\n  \n  // Act (실행)\n  fireEvent.click(screen.getByRole('button'));\n  \n  // Assert (검증)\n  expect(handleClick).toHaveBeenCalledTimes(1);\n  expect(screen.getByText('Count: 1')).toBeInTheDocument();\n});"
    },
    {
      "title": "테스트 이름 작성 규칙",
      "description": "명확하고 설명적인 테스트 이름 사용",
      "example": "// ❌ Bad\nit('works', () => { ... });\nit('test1', () => { ... });\n\n// ✅ Good\nit('버튼 클릭 시 모달이 열려야 함', () => { ... });\nit('잘못된 이메일 입력 시 에러 메시지가 표시되어야 함', () => { ... });\nit('로딩 중에는 스피너가 표시되고 버튼이 비활성화되어야 함', () => { ... });"
    },
    {
      "title": "단일 책임 원칙 (Single Responsibility)",
      "description": "하나의 테스트는 하나의 동작만 검증",
      "example": "// ❌ Bad: 여러 동작을 한 테스트에서 검증\nit('폼이 정상 동작해야 함', () => {\n  // 렌더링 검증\n  // 입력 검증\n  // 제출 검증\n  // 에러 검증\n});\n\n// ✅ Good: 각 동작을 별도 테스트로 분리\nit('폼이 정상 렌더링되어야 함', () => { ... });\nit('입력 필드가 정상 동작해야 함', () => { ... });\nit('제출 시 데이터가 전송되어야 함', () => { ... });\nit('검증 실패 시 에러 메시지가 표시되어야 함', () => { ... });"
    },
    {
      "title": "비동기 테스트 처리",
      "description": "waitFor, findBy를 사용하여 비동기 동작 대기",
      "example": "// ❌ Bad: 비동기 대기 없이 즉시 검증\nit('데이터 로딩 후 표시', () => {\n  render(<MyComponent />);\n  expect(screen.getByText('Data')).toBeInTheDocument();  // 실패!\n});\n\n// ✅ Good: waitFor로 비동기 대기\nit('데이터 로딩 후 표시', async () => {\n  render(<MyComponent />);\n  \n  await waitFor(() => {\n    expect(screen.getByText('Data')).toBeInTheDocument();\n  });\n});\n\n// ✅ Better: findBy 사용 (자동 대기)\nit('데이터 로딩 후 표시', async () => {\n  render(<MyComponent />);\n  \n  const data = await screen.findByText('Data');\n  expect(data).toBeInTheDocument();\n});"
    }
  ],
  "commonErrors": [
    {
      "error": "\"not wrapped in act(...)\" 경고",
      "cause": "React 상태 업데이트가 테스트 외부에서 발생",
      "solution": "waitFor를 사용하여 상태 업데이트 대기:\n\nawait waitFor(() => {\n  expect(screen.getByText('Updated')).toBeInTheDocument();\n});"
    },
    {
      "error": "\"Unable to find element\" 에러",
      "cause": "요소가 렌더링되지 않았거나 잘못된 쿼리 사용",
      "solution": "1. screen.debug()로 현재 DOM 확인\n2. getByRole, getByText 등 올바른 쿼리 사용\n3. 비동기인 경우 findBy 또는 waitFor 사용"
    },
    {
      "error": "\"Cannot read property of undefined\" 에러",
      "cause": "모킹되지 않은 의존성 호출",
      "solution": "jest.mock()으로 의존성 모킹:\n\njest.mock('@/lib/api');\nconst mockFetchData = fetchData as jest.MockedFunction<typeof fetchData>;\nmockFetchData.mockResolvedValue([]);"
    }
  ]
}