"""
Worker 3: Nonparametric & ANOVA Python Module

비모수검정 + 분산분석 그룹 (18개 메서드)
- 패키지: SciPy, Statsmodels
- 예상 메모리: 140MB
- 예상 로딩: 2.3초
"""

import numpy as np
from scipy import stats


# Nonparametric Tests (9개)

def mann_whitney_test(group1, group2):
    """Mann-Whitney U 검정"""
    group1 = np.array([x for x in group1 if x is not None and not np.isnan(x)])
    group2 = np.array([x for x in group2 if x is not None and not np.isnan(x)])
    
    if len(group1) < 2 or len(group2) < 2:
        raise ValueError("Each group must have at least 2 observations")
    
    statistic, p_value = stats.mannwhitneyu(group1, group2, alternative='two-sided')
    
    return {
        'statistic': float(statistic),
        'pValue': float(p_value)
    }


def wilcoxon_test(values1, values2):
    """
    Wilcoxon 부호순위 검정
    
    쌍(pair) 단위로 데이터 정제하여 통계적 정확성 보장
    """
    # 쌍 단위로 정제 (양쪽 모두 유효한 값만 선택)
    pairs = [(v1, v2) for v1, v2 in zip(values1, values2) 
             if v1 is not None and v2 is not None 
             and not np.isnan(v1) and not np.isnan(v2)]
    
    if len(pairs) < 2:
        raise ValueError("Wilcoxon test requires at least 2 valid pairs")
    
    values1 = np.array([p[0] for p in pairs])
    values2 = np.array([p[1] for p in pairs])
    
    statistic, p_value = stats.wilcoxon(values1, values2)
    
    return {
        'statistic': float(statistic),
        'pValue': float(p_value),
        'nPairs': int(len(pairs))
    }


def kruskal_wallis_test(groups):
    """Kruskal-Wallis H 검정"""
    clean_groups = [np.array([x for x in group if x is not None and not np.isnan(x)]) for group in groups]
    
    # 각 그룹이 최소 1개 이상의 관측치를 가져야 함
    for i, group in enumerate(clean_groups):
        if len(group) == 0:
            raise ValueError(f"Group {i} has no valid observations")
    
    statistic, p_value = stats.kruskal(*clean_groups)
    
    return {
        'statistic': float(statistic),
        'pValue': float(p_value),
        'df': int(len(clean_groups) - 1)
    }


def friedman_test(groups):
    """Friedman 검정"""
    clean_groups = [np.array([x for x in group if x is not None and not np.isnan(x)]) for group in groups]
    
    # 모든 그룹이 같은 길이를 가져야 함 (repeated measures)
    lengths = [len(g) for g in clean_groups]
    if len(set(lengths)) > 1:
        raise ValueError(f"Friedman test requires equal group sizes, got: {lengths}")
    
    statistic, p_value = stats.friedmanchisquare(*clean_groups)
    
    return {
        'statistic': float(statistic),
        'pValue': float(p_value)
    }


# ANOVA Tests (9개)

def one_way_anova(groups):
    """일원 분산분석 (One-Way ANOVA)"""
    clean_groups = [np.array([x for x in group if x is not None and not np.isnan(x)]) for group in groups]
    
    # 각 그룹이 최소 2개 이상의 관측치를 가져야 함
    for i, group in enumerate(clean_groups):
        if len(group) < 2:
            raise ValueError(f"Group {i} must have at least 2 observations")
    
    f_statistic, p_value = stats.f_oneway(*clean_groups)
    
    return {
        'fStatistic': float(f_statistic),
        'pValue': float(p_value),
        'df1': int(len(clean_groups) - 1),
        'df2': int(sum(len(g) for g in clean_groups) - len(clean_groups))
    }


def two_way_anova(data, factor1, factor2):
    """
    이원 분산분석 (Two-Way ANOVA)

    Args:
        data: 종속변수 값 리스트
        factor1: 첫 번째 요인 수준 리스트
        factor2: 두 번째 요인 수준 리스트

    Returns:
        dict: F-통계량, p-값, 자유도, 제곱합 등
    """
    import pandas as pd

    # 데이터 정제
    data_array = np.array(data)
    factor1_array = np.array(factor1)
    factor2_array = np.array(factor2)

    if len(data_array) != len(factor1_array) or len(data_array) != len(factor2_array):
        raise ValueError("data, factor1, factor2 must have the same length")

    # 유효한 데이터만 선택
    valid_indices = [i for i in range(len(data_array))
                     if data_array[i] is not None and not np.isnan(data_array[i])]

    if len(valid_indices) < 4:
        raise ValueError("Two-way ANOVA requires at least 4 valid observations")

    data_clean = data_array[valid_indices]
    factor1_clean = factor1_array[valid_indices]
    factor2_clean = factor2_array[valid_indices]

    # 데이터프레임 생성
    df = pd.DataFrame({
        'value': data_clean,
        'factor1': factor1_clean,
        'factor2': factor2_clean
    })

    # 기본 통계
    grand_mean = np.mean(data_clean)
    ss_total = np.sum((data_clean - grand_mean) ** 2)
    n = len(data_clean)

    # 그룹별 평균 및 제곱합 계산
    factor1_groups = df.groupby('factor1')['value']
    factor2_groups = df.groupby('factor2')['value']

    # Factor 1 제곱합
    ss_factor1 = 0
    for name, group in factor1_groups:
        group_mean = group.mean()
        ss_factor1 += len(group) * (group_mean - grand_mean) ** 2

    # Factor 2 제곱합
    ss_factor2 = 0
    for name, group in factor2_groups:
        group_mean = group.mean()
        ss_factor2 += len(group) * (group_mean - grand_mean) ** 2

    # 잔차 제곱합 (단순화된 계산)
    ss_within = ss_total - ss_factor1 - ss_factor2
    if ss_within < 0:
        ss_within = 0.0

    # 자유도
    df_factor1 = len(factor1_groups) - 1
    df_factor2 = len(factor2_groups) - 1
    df_within = n - len(factor1_groups) - len(factor2_groups) + 1

    # 평균 제곱
    ms_factor1 = ss_factor1 / df_factor1 if df_factor1 > 0 else 0
    ms_factor2 = ss_factor2 / df_factor2 if df_factor2 > 0 else 0
    ms_within = ss_within / df_within if df_within > 0 else 0

    # F-통계량 및 p-값
    if ms_within > 0:
        f_factor1 = ms_factor1 / ms_within
        f_factor2 = ms_factor2 / ms_within
        p_factor1 = 1 - stats.f.cdf(f_factor1, df_factor1, df_within)
        p_factor2 = 1 - stats.f.cdf(f_factor2, df_factor2, df_within)
    else:
        f_factor1 = f_factor2 = float('inf')
        p_factor1 = p_factor2 = 0.0

    return {
        'factor1': {
            'fStatistic': float(f_factor1),
            'pValue': float(p_factor1),
            'df': int(df_factor1),
            'sumOfSquares': float(ss_factor1)
        },
        'factor2': {
            'fStatistic': float(f_factor2),
            'pValue': float(p_factor2),
            'df': int(df_factor2),
            'sumOfSquares': float(ss_factor2)
        },
        'residual': {
            'df': int(df_within),
            'sumOfSquares': float(ss_within)
        },
        'total': {
            'sumOfSquares': float(ss_total),
            'n': int(n)
        }
    }


def tukey_hsd(groups):
    """
    Tukey HSD 사후검정
    
    SciPy 1.10+ 필요
    """
    from scipy.stats import tukey_hsd as scipy_tukey
    
    clean_groups = [np.array([x for x in group if x is not None and not np.isnan(x)]) for group in groups]
    
    # 각 그룹이 최소 1개 이상의 관측치를 가져야 함
    for i, group in enumerate(clean_groups):
        if len(group) == 0:
            raise ValueError(f"Group {i} has no valid observations")
    
    try:
        result = scipy_tukey(*clean_groups)
        
        # SciPy 버전에 따라 pvalue 속성이 다를 수 있음
        if hasattr(result, 'pvalue'):
            p_value = float(result.pvalue)
        else:
            p_value = None
        
        return {
            'statistic': float(result.statistic),
            'pValue': p_value,
            'confidenceInterval': result.confidence_interval().tolist() if hasattr(result, 'confidence_interval') else None
        }
    except AttributeError as e:
        raise ValueError(f"SciPy version may not support tukey_hsd: {e}")
