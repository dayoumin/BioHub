{
  "id": "test-snippets",
  "version": "1.22.0",
  "lastUpdated": "2026-02-28",
  "sources": [
    "stats/__tests__/",
    "stats/jest.config.js"
  ],
  "categories": [
    {
      "name": "Zustand Store Tests",
      "description": "Zustand 스토어 계약 테스트 패턴 (act 래핑, beforeEach 리셋)",
      "patterns": [
        {
          "name": "Zustand 스토어 액션 테스트",
          "purpose": "Zustand store의 액션이 상태를 올바르게 변경하는지 검증",
          "code": "import { describe, it, expect, beforeEach } from 'vitest';\nimport { act } from '@testing-library/react';\nimport { useMyStore } from '@/lib/stores/my-store';\n\n// 공통 리셋: 각 테스트 독립성 보장\nbeforeEach(() => {\n  act(() => {\n    useMyStore.getState().resetAll();\n  });\n});\n\ndescribe('MyStore 계약', () => {\n  it('초기 상태가 올바르다', () => {\n    const state = useMyStore.getState();\n    expect(state.value).toBeNull();\n  });\n\n  it('setValue 액션이 상태를 변경한다', () => {\n    act(() => {\n      useMyStore.getState().setValue('hello');\n    });\n    expect(useMyStore.getState().value).toBe('hello');\n  });\n\n  it('제거된 필드가 state에 없다 (dead state 검증)', () => {\n    const state = useMyStore.getState();\n    expect('removedField' in state).toBe(false);\n  });\n});",
          "keywords": ["zustand", "act", "getState", "beforeEach", "resetAll"]
        },
        {
          "name": "localStorage 모킹 (project-storage 등)",
          "purpose": "localStorage를 사용하는 유틸 함수 테스트",
          "code": "import { describe, it, expect, beforeEach, vi } from 'vitest';\nimport { saveItem, loadItem } from '@/lib/storage';\n\n// localStorage 모킹\nconst mockStorage: Record<string, string> = {};\nObject.defineProperty(globalThis, 'localStorage', {\n  value: {\n    getItem: (k: string) => mockStorage[k] ?? null,\n    setItem: (k: string, v: string) => { mockStorage[k] = v; },\n    removeItem: (k: string) => { delete mockStorage[k]; },\n  },\n  writable: true,\n});\n\nbeforeEach(() => {\n  Object.keys(mockStorage).forEach(k => delete mockStorage[k]);\n});\n\ndescribe('storage utils', () => {\n  it('저장 후 불러오기', () => {\n    saveItem('key', { a: 1 });\n    expect(loadItem('key')).toEqual({ a: 1 });\n  });\n\n  it('없는 키는 null 반환', () => {\n    expect(loadItem('missing')).toBeNull();\n  });\n});",
          "keywords": ["localStorage", "vi", "mock", "defineProperty", "storage"]
        }
      ]
    },
    {
      "name": "React Component Tests",
      "description": "React 컴포넌트 테스트 패턴",
      "patterns": [
        {
          "name": "기본 렌더링 테스트",
          "purpose": "컴포넌트가 정상적으로 렌더링되는지 확인",
          "code": "import { render, screen } from '@testing-library/react';\nimport { MyComponent } from '@/components/MyComponent';\n\ndescribe('MyComponent', () => {\n  it('기본 렌더링이 정상적으로 동작해야 함', () => {\n    render(<MyComponent />);\n    \n    expect(screen.getByText('Hello')).toBeInTheDocument();\n    expect(screen.getByRole('button')).toBeInTheDocument();\n  });\n});",
          "keywords": [
            "render",
            "screen",
            "getByText",
            "toBeInTheDocument"
          ]
        },
        {
          "name": "이벤트 핸들링 테스트",
          "purpose": "사용자 이벤트(클릭, 입력 등)가 정상 동작하는지 확인",
          "code": "import { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport { MyComponent } from '@/components/MyComponent';\n\ndescribe('MyComponent 이벤트', () => {\n  it('버튼 클릭 시 콜백이 호출되어야 함', async () => {\n    const handleClick = jest.fn();\n    render(<MyComponent onClick={handleClick} />);\n    \n    fireEvent.click(screen.getByRole('button'));\n    \n    await waitFor(() => {\n      expect(handleClick).toHaveBeenCalledTimes(1);\n    });\n  });\n  \n  it('입력 필드에 텍스트 입력 시 상태가 업데이트되어야 함', () => {\n    render(<MyComponent />);\n    \n    const input = screen.getByPlaceholderText('Enter text');\n    fireEvent.change(input, { target: { value: 'Hello' } });\n    \n    expect(input).toHaveValue('Hello');\n  });\n});",
          "keywords": [
            "fireEvent",
            "click",
            "change",
            "waitFor"
          ]
        },
        {
          "name": "비동기 데이터 로딩 테스트",
          "purpose": "비동기 데이터 로딩 및 로딩 상태 확인",
          "code": "import { render, screen, waitFor } from '@testing-library/react';\nimport { MyComponent } from '@/components/MyComponent';\nimport { fetchData } from '@/lib/api';\n\njest.mock('@/lib/api');\nconst mockFetchData = fetchData as jest.MockedFunction<typeof fetchData>;\n\ndescribe('MyComponent 비동기', () => {\n  it('로딩 중에는 스피너가 표시되어야 함', async () => {\n    mockFetchData.mockImplementation(() => \n      new Promise(resolve => setTimeout(() => resolve([]), 1000))\n    );\n    \n    render(<MyComponent />);\n    \n    // 로딩 스피너 확인\n    expect(screen.getByRole('status')).toBeInTheDocument();\n    \n    // 데이터 로딩 완료 후\n    await waitFor(() => {\n      expect(screen.queryByRole('status')).not.toBeInTheDocument();\n    });\n  });\n  \n  it('데이터 로딩 실패 시 에러 메시지가 표시되어야 함', async () => {\n    mockFetchData.mockRejectedValue(new Error('Failed to fetch'));\n    \n    render(<MyComponent />);\n    \n    await waitFor(() => {\n      expect(screen.getByText(/Failed to fetch/)).toBeInTheDocument();\n    });\n  });\n});",
          "keywords": [
            "mock",
            "mockResolvedValue",
            "mockRejectedValue",
            "waitFor"
          ]
        }
      ]
    },
    {
      "name": "Schema Validation Tests",
      "description": "스키마 검증 테스트 패턴 (통계 결과 일관성 보장)",
      "patterns": [
        {
          "name": "카테고리별 필수 필드 검증",
          "purpose": "통계 방법별 필수 필드 존재 여부 확인",
          "code": "import { describe, it, expect } from '@jest/globals';\nimport { validateResultSchema, getCategoryForMethod } from '@/lib/validation/result-schema-validator';\nimport type { AnalysisResult } from '@/types/smart-flow';\n\ndescribe('Result Schema Validator', () => {\n  it('should pass when all required fields exist', () => {\n    const result: AnalysisResult = {\n      method: 'Independent t-test',\n      statistic: 2.5,\n      pValue: 0.05,\n      interpretation: 'Significant difference found'\n    };\n\n    const validation = validateResultSchema(result, 't-test');\n\n    expect(validation.valid).toBe(true);\n    expect(validation.missing).toHaveLength(0);\n    expect(validation.category).toBe('comparison');\n  });\n\n  it('should fail when required field is missing', () => {\n    const result = {\n      method: 'regression',\n      statistic: 15.3,\n      pValue: 0.001,\n      interpretation: 'Model fit'\n      // missing additional.rSquared\n    } as AnalysisResult;\n\n    const validation = validateResultSchema(result, 'regression');\n\n    expect(validation.valid).toBe(false);\n    expect(validation.missing).toContain('additional.rSquared');\n  });\n});",
          "keywords": [
            "schema validation",
            "required fields",
            "category mapping"
          ]
        },
        {
          "name": "Method ID 정규화 검증",
          "purpose": "다양한 method ID 형식이 올바른 카테고리로 매핑되는지 확인",
          "code": "describe('Method ID Normalization', () => {\n  it('should map executor-facing IDs correctly', () => {\n    // executor에서 사용하는 짧은 ID들\n    expect(getCategoryForMethod('simple')).toBe('regression');\n    expect(getCategoryForMethod('multiple')).toBe('regression');\n    expect(getCategoryForMethod('logistic')).toBe('regression');\n  });\n\n  it('should normalize method IDs with spaces', () => {\n    expect(getCategoryForMethod('t test')).toBe('comparison');\n    expect(getCategoryForMethod('chi square')).toBe('goodnessOfFit');\n  });\n\n  it('should handle case insensitive method IDs', () => {\n    expect(getCategoryForMethod('T-TEST')).toBe('comparison');\n    expect(getCategoryForMethod('ANOVA')).toBe('comparison');\n  });\n\n  it('should default to comparison for unknown methods', () => {\n    expect(getCategoryForMethod('unknown-method')).toBe('comparison');\n  });\n});",
          "keywords": [
            "method ID",
            "normalization",
            "case insensitive"
          ]
        },
        {
          "name": "배치 검증 테스트",
          "purpose": "여러 결과를 동시에 검증하고 실패한 method 식별",
          "code": "import { validateBatch } from '@/lib/validation/result-schema-validator';\n\ndescribe('Batch Validation', () => {\n  it('should validate multiple results at once', () => {\n    const results = [\n      { methodId: 't-test', result: { method: 't-test', statistic: 2.5, pValue: 0.05, interpretation: 'Significant' } },\n      { methodId: 'regression', result: { method: 'regression', statistic: 15.3, pValue: 0.001, interpretation: 'Model fit' } }\n    ];\n\n    const batch = validateBatch(results);\n\n    expect(batch.allValid).toBe(false);\n    expect(batch.failedMethods).toContain('regression');\n    expect(batch.failedMethods).not.toContain('t-test');\n  });\n});",
          "keywords": [
            "batch validation",
            "multiple results",
            "failed methods"
          ]
        }
      ]
    },
    {
      "name": "Integration Tests",
      "description": "통합 테스트 패턴 (프론트-백엔드 연결)",
      "patterns": [
        {
          "name": "데이터 구조 검증",
          "purpose": "프론트 → Python Worker 데이터 구조 일치 확인",
          "code": "import { describe, it, expect } from '@jest/globals';\n\ndescribe('ANOVA Integration Tests', () => {\n  it('데이터 구조가 Python Worker와 일치해야 함', () => {\n    // 프론트에서 준비하는 데이터 구조\n    const dataValues = [10, 12, 14, 16, 18, 20];\n    const factor1Values = ['A', 'A', 'B', 'B', 'C', 'C'];\n    \n    // 검증: 배열 길이 일치\n    expect(dataValues.length).toBe(factor1Values.length);\n    \n    // 검증: 최소 데이터 (4개 이상)\n    expect(dataValues.length).toBeGreaterThanOrEqual(4);\n    \n    // 검증: 데이터 타입\n    expect(Array.isArray(dataValues)).toBe(true);\n    expect(dataValues.every(v => typeof v === 'number')).toBe(true);\n  });\n});",
          "keywords": [
            "integration",
            "data validation",
            "Python Worker"
          ]
        },
        {
          "name": "Python Worker 파라미터 검증",
          "purpose": "Python Worker 호출 시 파라미터 형식 확인",
          "code": "import { describe, it, expect } from '@jest/globals';\n\ndescribe('Python Worker 파라미터', () => {\n  it('파라미터가 올바른 형식이어야 함', () => {\n    const params = {\n      data_values: [10, 12, 14, 16],\n      factor1_values: ['A', 'A', 'B', 'B'],\n      factor2_values: ['Low', 'High', 'Low', 'High']\n    };\n    \n    // 검증: 필수 키 존재\n    expect(params).toHaveProperty('data_values');\n    expect(params).toHaveProperty('factor1_values');\n    expect(params).toHaveProperty('factor2_values');\n    \n    // 검증: snake_case 사용 (Python 규약)\n    expect(Object.keys(params)).toEqual([\n      'data_values',\n      'factor1_values',\n      'factor2_values'\n    ]);\n  });\n});",
          "keywords": [
            "parameters",
            "snake_case",
            "validation"
          ]
        },
        {
          "name": "Python Worker 반환값 검증",
          "purpose": "Python Worker 반환값이 TypeScript 타입과 일치하는지 확인",
          "code": "import { describe, it, expect } from '@jest/globals';\n\ndescribe('Python Worker 반환값', () => {\n  it('반환 타입이 TwoWayANOVAResult와 일치해야 함', () => {\n    // Python Worker 반환 예상 구조\n    const mockResult = {\n      factor1: {\n        fStatistic: 5.2,\n        pValue: 0.032,\n        df: 1\n      },\n      factor2: {\n        fStatistic: 3.8,\n        pValue: 0.067,\n        df: 1\n      },\n      interaction: {\n        fStatistic: 2.1,\n        pValue: 0.165,\n        df: 1\n      },\n      residual: {\n        df: 8\n      }\n    };\n    \n    // 검증: 필수 필드 존재\n    expect(mockResult).toHaveProperty('factor1');\n    expect(mockResult).toHaveProperty('factor2');\n    expect(mockResult).toHaveProperty('interaction');\n    expect(mockResult).toHaveProperty('residual');\n    \n    // 검증: 숫자 타입\n    expect(typeof mockResult.factor1.fStatistic).toBe('number');\n    expect(typeof mockResult.factor1.pValue).toBe('number');\n  });\n});",
          "keywords": [
            "return type",
            "validation",
            "TypeScript"
          ]
        },
        {
          "name": "그룹 수 검증 테스트",
          "purpose": "통계 분석 실행 전 그룹 수 및 관측치 수 검증",
          "code": "import { StatisticalExecutor } from '@/lib/services/statistical-executor'\n\njest.mock('@/lib/services/pyodide-statistics', () => ({\n  pyodideStats: {\n    tTest: jest.fn(),\n    mannWhitneyU: jest.fn(),\n  }\n}))\n\ndescribe('StatisticalExecutor group validation', () => {\n  let executor: StatisticalExecutor\n\n  beforeEach(() => {\n    executor = new StatisticalExecutor()\n    jest.clearAllMocks()\n  })\n\n  it('t-test: rejects when group count is not exactly 2', async () => {\n    const method = { id: 'welch-t', name: 'Welch t', category: 't-test' } as any\n    const preparedData = {\n      arrays: {\n        byGroup: { A: [1, 2], B: [3, 4], C: [5, 6] }\n      }\n    } as any\n\n    await expect((executor as any).executeTTest(method, preparedData))\n      .rejects.toThrow(/정확히 2개 그룹/)\n  })\n\n  it('t-test: rejects when any group has <2 observations', async () => {\n    const preparedData = {\n      arrays: {\n        byGroup: { 'A': [1], 'B': [1, 2, 3] }\n      }\n    } as any\n\n    await expect((executor as any).executeTTest(method, preparedData))\n      .rejects.toThrow(/각 그룹에 최소 2개 이상/)\n  })\n})",
          "keywords": [
            "group validation",
            "그룹 검증",
            "observation count",
            "StatisticalExecutor"
          ]
        }
      ]
    },
    {
      "name": "Mock Patterns",
      "description": "모킹 패턴 (외부 의존성 격리)",
      "patterns": [
        {
          "name": "함수 모킹",
          "purpose": "외부 함수를 모킹하여 테스트 격리",
          "code": "import { myFunction } from '@/lib/utils';\n\njest.mock('@/lib/utils');\nconst mockMyFunction = myFunction as jest.MockedFunction<typeof myFunction>;\n\ndescribe('함수 모킹', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n  \n  it('함수가 호출되어야 함', () => {\n    mockMyFunction.mockReturnValue(42);\n    \n    const result = mockMyFunction(10);\n    \n    expect(mockMyFunction).toHaveBeenCalledWith(10);\n    expect(result).toBe(42);\n  });\n  \n  it('비동기 함수 모킹', async () => {\n    mockMyFunction.mockResolvedValue({ data: 'success' });\n    \n    const result = await mockMyFunction();\n    \n    expect(result).toEqual({ data: 'success' });\n  });\n});",
          "keywords": [
            "jest.mock",
            "mockReturnValue",
            "mockResolvedValue"
          ]
        },
        {
          "name": "모듈 모킹",
          "purpose": "전체 모듈을 모킹하여 복잡한 의존성 제거",
          "code": "// Mock markdown dependencies (ESM modules)\njest.mock('remark-gfm', () => ({}));\njest.mock('remark-breaks', () => ({}));\njest.mock('react-markdown', () => ({\n  __esModule: true,\n  default: ({ children }: { children: string }) => <div>{children}</div>\n}));\n\n// Mock 컴포넌트\njest.mock('@/components/rag/chat-sources-display', () => ({\n  ChatSourcesDisplay: () => <div data-testid=\"chat-sources\">Sources</div>\n}));\n\ndescribe('모듈 모킹', () => {\n  it('모킹된 컴포넌트가 렌더링되어야 함', () => {\n    render(<MyComponent />);\n    \n    expect(screen.getByTestId('chat-sources')).toBeInTheDocument();\n  });\n});",
          "keywords": [
            "jest.mock",
            "__esModule",
            "module mocking"
          ]
        },
        {
          "name": "window 객체 모킹",
          "purpose": "브라우저 API (window.open, localStorage 등) 모킹",
          "code": "const mockWindowOpen = jest.fn();\nconst mockLocalStorage = {\n  getItem: jest.fn(),\n  setItem: jest.fn(),\n  removeItem: jest.fn(),\n  clear: jest.fn()\n};\n\ndescribe('window 객체 모킹', () => {\n  beforeEach(() => {\n    window.open = mockWindowOpen;\n    Object.defineProperty(window, 'localStorage', {\n      value: mockLocalStorage,\n      writable: true\n    });\n  });\n  \n  it('window.open이 호출되어야 함', () => {\n    render(<MyComponent />);\n    \n    fireEvent.click(screen.getByText('새 창 열기'));\n    \n    expect(mockWindowOpen).toHaveBeenCalledWith('/chatbot', '_blank');\n  });\n  \n  it('localStorage가 호출되어야 함', () => {\n    mockLocalStorage.getItem.mockReturnValue('saved-value');\n    \n    render(<MyComponent />);\n    \n    expect(mockLocalStorage.getItem).toHaveBeenCalledWith('key');\n  });\n});",
          "keywords": [
            "window.open",
            "localStorage",
            "browser API"
          ]
        },
        {
          "name": "IndexedDB graceful degradation",
          "purpose": "브라우저 호환성 (Safari/Firefox에서 미지원 API 처리)",
          "code": "describe('IndexedDB cleanup graceful degradation', () => {\n  it('indexedDB.databases가 undefined일 때도 에러 없이 처리되어야 함', async () => {\n    // Safari/Firefox 시뮬레이션: databases 메서드가 없음\n    const mockIndexedDB = {\n      deleteDatabase: jest.fn(),\n      // databases 메서드 없음 (undefined)\n    };\n\n    Object.defineProperty(window, 'indexedDB', {\n      value: mockIndexedDB,\n      writable: true,\n    });\n\n    const cleanupIndexedDB = async () => {\n      try {\n        if (typeof window.indexedDB.databases === 'function') {\n          const databases = await window.indexedDB.databases();\n          for (const db of databases) {\n            if (db.name) {\n              window.indexedDB.deleteDatabase(db.name);\n            }\n          }\n        }\n      } catch (e) {\n        console.warn('[Settings] IndexedDB cleanup failed:', e);\n      }\n    };\n\n    await expect(cleanupIndexedDB()).resolves.not.toThrow();\n    expect(mockIndexedDB.deleteDatabase).not.toHaveBeenCalled();\n  });\n\n  it('indexedDB.databases가 에러를 던져도 graceful하게 처리되어야 함', async () => {\n    const consoleWarnSpy = jest.spyOn(console, 'warn').mockImplementation();\n    const mockIndexedDB = {\n      databases: jest.fn().mockRejectedValue(new Error('Not supported')),\n      deleteDatabase: jest.fn(),\n    };\n\n    Object.defineProperty(window, 'indexedDB', {\n      value: mockIndexedDB,\n      writable: true,\n    });\n\n    // ... cleanup 로직 ...\n    await expect(cleanupIndexedDB()).resolves.not.toThrow();\n    expect(consoleWarnSpy).toHaveBeenCalled();\n    consoleWarnSpy.mockRestore();\n  });\n});",
          "keywords": [
            "indexedDB",
            "browser compatibility",
            "feature detection",
            "graceful degradation",
            "Safari",
            "Firefox"
          ]
        }
      ]
    },
    {
      "name": "Regression Tests",
      "description": "회귀 테스트 패턴 (버그 재발 방지)",
      "patterns": [
        {
          "name": "Method Matching Regression",
          "purpose": "메서드명 매칭 로직의 버그 수정 검증",
          "code": "import { getInterpretation } from '@/lib/interpretation/engine';\nimport type { AnalysisResult } from '@/types/smart-flow';\n\ndescribe('T-Test Method Matching Regression Tests', () => {\n  describe('Independent Samples t-test - should match', () => {\n    it('Independent t-test (basic)', () => {\n      const results: AnalysisResult = {\n        method: 'Independent t-test',\n        pValue: 0.03,\n        statistic: 2.5,\n        interpretation: ''\n      };\n\n      const interpretation = getInterpretation(results);\n\n      expect(interpretation).not.toBeNull();\n      expect(interpretation?.title).toContain('t');\n    });\n  });\n\n  describe('Non-t-test methods with \"independent\" - should NOT match t-test', () => {\n    it('Independent KS Test should NOT match t-test', () => {\n      const results: AnalysisResult = {\n        method: 'Independent KS Test',\n        pValue: 0.02,\n        statistic: 0.35,\n        interpretation: ''\n      };\n\n      const interpretation = getInterpretation(results);\n\n      // Should return null or match a different interpretation (not t-test)\n      if (interpretation !== null) {\n        expect(interpretation.title).not.toContain('t');\n      }\n    });\n  });\n});",
          "keywords": [
            "regression",
            "method matching",
            "interpretation engine",
            "pattern matching"
          ]
        }
      ]
    },
    {
      "name": "Golden Values Tests",
      "description": "통계 계산 정확도 검증 (Phase 2.5) - 5개 Python 라이브러리",
      "patterns": [
        {
          "name": "Schema Validation Test",
          "purpose": "golden-values.json 스키마 구조 검증",
          "code": "import * as fs from 'fs';\nimport * as path from 'path';\n\nconst goldenValues = JSON.parse(fs.readFileSync(\n  path.join(__dirname, 'statistical-golden-values.json'), 'utf-8'\n));\n\ndescribe('Golden Values Schema Validation', () => {\n  it('should have valid schema structure', () => {\n    expect(goldenValues).toHaveProperty('$schema');\n    expect(goldenValues).toHaveProperty('verificationSources');\n    expect(goldenValues).toHaveProperty('lastUpdated');\n  });\n\n  it('should have multiple verification sources', () => {\n    const sources = goldenValues.verificationSources;\n    expect(sources).toHaveProperty('scipy');\n    expect(sources).toHaveProperty('statsmodels');\n    expect(sources).toHaveProperty('pingouin');\n    expect(sources).toHaveProperty('sklearn');\n    expect(sources).toHaveProperty('lifelines');\n  });\n});",
          "keywords": [
            "golden values",
            "schema",
            "verification",
            "scipy"
          ]
        },
        {
          "name": "Category Test Cases Validation",
          "purpose": "카테고리별 테스트 케이스 필수 필드 검증",
          "code": "describe('T-Test Golden Values', () => {\n  describe('One-Sample T-Test', () => {\n    it('should have valid test cases', () => {\n      const testCases = goldenValues.tTest.oneSample;\n      expect(testCases.length).toBeGreaterThan(0);\n\n      for (const tc of testCases) {\n        expect(tc).toHaveProperty('name');\n        expect(tc).toHaveProperty('input');\n        expect(tc).toHaveProperty('expected');\n        expect(tc).toHaveProperty('tolerance');\n        expect(tc.input).toHaveProperty('data');\n        expect(Array.isArray(tc.input.data)).toBe(true);\n      }\n    });\n  });\n});",
          "keywords": [
            "golden values",
            "test cases",
            "validation"
          ]
        },
        {
          "name": "Multi-Library Test Pattern",
          "purpose": "다중 Python 라이브러리 검증 패턴",
          "code": "describe('Survival Analysis Golden Values', () => {\n  describe('Kaplan-Meier', () => {\n    it('should have valid test cases', () => {\n      const testCases = goldenValues.survival.kaplanMeier;\n      expect(testCases.length).toBeGreaterThan(0);\n\n      for (const tc of testCases) {\n        expect(tc.input).toHaveProperty('times');\n        expect(tc.input).toHaveProperty('events');\n        expect(tc.library).toBe('lifelines');  // 라이브러리 명시\n      }\n    });\n  });\n});",
          "keywords": [
            "lifelines",
            "survival",
            "kaplan-meier",
            "multi-library"
          ]
        }
      ]
    },
    {
      "name": "Interpretation Engine Tests",
      "description": "통계 해석 엔진 테스트 (생존분석, 고급 ANOVA)",
      "patterns": [
        {
          "name": "createTestInput Helper",
          "purpose": "확장된 additional 필드로 테스트 입력 생성",
          "code": "import type { AnalysisResult } from '@/types/smart-flow';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction createTestInput(base: Omit<AnalysisResult, 'additional'>, additional: Record<string, any>): AnalysisResult {\n  return {\n    ...base,\n    additional: additional as AnalysisResult['additional']\n  };\n}",
          "keywords": [
            "interpretation",
            "test helper",
            "type casting"
          ]
        },
        {
          "name": "Survival Analysis Interpretation",
          "purpose": "생존분석(Kaplan-Meier, Cox) 해석 테스트",
          "code": "describe('Kaplan-Meier Survival Analysis', () => {\n  it('should interpret significant survival difference', () => {\n    const result = getInterpretation(createTestInput({\n      method: 'Kaplan-Meier',\n      statistic: 8.5,  // Log-rank chi-square\n      pValue: 0.003,\n      interpretation: ''\n    }, {\n      medianSurvival1: 24,\n      medianSurvival2: 18,\n      logRankStatistic: 8.5,\n      hazardRatio: 0.65\n    }));\n\n    if (result) {\n      expect(result.title).toBeDefined();\n      expect(result.summary).toBeDefined();\n    }\n  });\n});",
          "keywords": [
            "survival",
            "kaplan-meier",
            "interpretation"
          ]
        }
      ]
    },
    {
      "name": "Test Setup & Teardown",
      "description": "테스트 설정 및 정리 패턴",
      "patterns": [
        {
          "name": "beforeEach / afterEach",
          "purpose": "각 테스트 전/후 설정 및 정리",
          "code": "describe('MyComponent', () => {\n  beforeEach(() => {\n    // 각 테스트 전에 실행\n    jest.clearAllMocks();\n    localStorage.clear();\n  });\n  \n  afterEach(() => {\n    // 각 테스트 후에 실행\n    jest.restoreAllMocks();\n  });\n  \n  it('테스트 1', () => {\n    // ...\n  });\n  \n  it('테스트 2', () => {\n    // ...\n  });\n});",
          "keywords": [
            "beforeEach",
            "afterEach",
            "setup",
            "teardown"
          ]
        },
        {
          "name": "beforeAll / afterAll",
          "purpose": "모든 테스트 전/후 한 번만 실행",
          "code": "describe('MyComponent', () => {\n  beforeAll(() => {\n    // 모든 테스트 전에 한 번만 실행\n    console.log('테스트 시작');\n  });\n  \n  afterAll(() => {\n    // 모든 테스트 후에 한 번만 실행\n    console.log('테스트 종료');\n  });\n  \n  it('테스트 1', () => {\n    // ...\n  });\n  \n  it('테스트 2', () => {\n    // ...\n  });\n});",
          "keywords": [
            "beforeAll",
            "afterAll",
            "global setup"
          ]
        },
        {
          "name": "테스트 격리 (Isolation)",
          "purpose": "각 테스트가 독립적으로 실행되도록 보장",
          "code": "describe('격리된 테스트', () => {\n  let mockData: any;\n  \n  beforeEach(() => {\n    // 각 테스트마다 새로운 데이터 생성\n    mockData = {\n      id: Math.random(),\n      name: 'Test',\n      items: []\n    };\n  });\n  \n  it('테스트 1이 mockData를 수정해도', () => {\n    mockData.name = 'Modified';\n    expect(mockData.name).toBe('Modified');\n  });\n  \n  it('테스트 2는 원본 mockData를 받음', () => {\n    // beforeEach로 새로 생성됨\n    expect(mockData.name).toBe('Test');\n  });\n});",
          "keywords": [
            "isolation",
            "independent tests",
            "fresh data"
          ]
        }
      ]
    },
    {
      "name": "Pyodide Worker Tests",
      "description": "Pyodide Worker 매핑 검증 테스트 패턴",
      "patterns": [
        {
          "name": "Worker-Function 매핑 검증",
          "purpose": "TypeScript에서 호출하는 함수가 실제 Python Worker 파일에 존재하는지 검증",
          "code": "extractFunctionsFromWorker(workerNum): Worker 파일에서 def function_name( 패턴으로 함수 추출\n\nEXPECTED_MAPPINGS: { worker: number, function: string, tsMethod: string }[]\n\nit(`${tsMethod}() → Worker ${worker}의 ${pyFunc}() 함수가 존재해야 함`, () => {\n  expect(workerFunctions[worker]).toContain(pyFunc);\n});",
          "keywords": [
            "Worker",
            "Pyodide",
            "function mapping",
            "Python"
          ]
        },
        {
          "name": "양방향 동기화 검증 (Bidirectional Sync)",
          "purpose": "서비스 메서드 추가/삭제 시 EXPECTED_MAPPINGS 업데이트를 강제하여 누락 방지",
          "code": "// 1. 서비스 파일에서 메서드 추출\nfunction extractServiceMethods() {\n  const content = readFileSync(SERVICE_PATH, 'utf8')\n  const pattern = /asyncs+(w+).*callWorkerMethod.*((d),.*['\"]([w_]+)['\"]/g\n  // ... 추출 로직\n}\n\n// 2. 양방향 검증 테스트\nit('서비스의 모든 메서드가 EXPECTED_MAPPINGS에 등록되어 있어야 함', () => {\n  const serviceMethods = extractServiceMethods()\n  const testedMethods = EXPECTED_MAPPINGS.map(m => m.tsMethod)\n  const untestedMethods = serviceMethods.filter(m => !testedMethods.includes(m.tsMethod))\n  \n  if (untestedMethods.length > 0) {\n    throw new Error('EXPECTED_MAPPINGS에 추가하세요: ' + untestedMethods.map(m => m.tsMethod))\n  }\n})\n\nit('EXPECTED_MAPPINGS의 모든 메서드가 서비스에 존재해야 함', () => {\n  // 삭제된 메서드 감지 → EXPECTED_MAPPINGS에서도 제거 강제\n})",
          "keywords": [
            "Bidirectional",
            "Sync",
            "동기화",
            "양방향",
            "EXPECTED_MAPPINGS"
          ]
        },
        {
          "name": "파라미터 시그니처 검증 (Parameter Signature)",
          "purpose": "TypeScript → Python 파라미터 이름/개수 일치 여부 검증",
          "code": "// 파라미터 시그니처 검증 테스트\n// 목적: 런타임 TypeError 사전 방지\n\n// 1. Python 함수 파라미터 추출\nfunction extractPythonFunctionParams(workerNum, funcName) {\n  const content = readFileSync(workerPath, 'utf8')\n  const pattern = new RegExp(`def ${funcName}\\\\(([^)]*)\\\\)`, 'm')\n  const match = content.match(pattern)\n  return match[1].split(',').map(p => p.split('=')[0].trim())\n}\n\n// 2. TypeScript 서비스 파라미터 키 추출\nfunction extractServiceCallParams(tsMethod) {\n  // callWorkerMethod(N, 'func', { key1, key2: value }) 에서 키 추출\n}\n\n// 3. 검증 테스트\nit('twoWayAnova 파라미터가 일치해야 함', () => {\n  const pyParams = extractPythonFunctionParams(3, 'two_way_anova')\n  expect(pyParams).toContain('data_values')\n  expect(pyParams).toContain('factor1_values')\n  expect(pyParams).toContain('factor2_values')\n})\n\n// 검증 항목:\n// - 필수 파라미터 존재 여부\n// - 파라미터 이름 일치 (snake_case)\n// - 최소 파라미터 개수",
          "keywords": [
            "parameter",
            "signature",
            "파라미터",
            "TypeError",
            "런타임"
          ]
        }
      ]
    },
    {
      "name": "Pyodide Worker Architecture",
      "description": "Pyodide Worker 매핑 구조 이해 및 관리 방법",
      "patterns": [
        {
          "name": "3계층 매핑 구조 (3-Layer Mapping)",
          "purpose": "TypeScript → Service → Python Worker 호출 흐름 이해",
          "code": "// === 3계층 매핑 구조 ===\n//\n// 1. TypeScript 메서드 (pyodide-core.service.ts)\n//    async twoSampleTTest(group1: number[], group2: number[]): Promise<StatisticsResult>\n//\n// 2. callWorkerMethod 호출 (Worker 번호 + Python 함수명)\n//    return this.callWorkerMethod<StatisticsResult>(2, 't_test_two_sample', { group1, group2 })\n//                                                   ^        ^\n//                                                   |        |\n//                                       Worker 번호(1-4)   Python 함수명\n//\n// 3. Python Worker 실행 (worker2-hypothesis.py)\n//    def t_test_two_sample(group1, group2):\n//        from scipy import stats\n//        return stats.ttest_ind(group1, group2)\n\n// === Worker 구성 ===\n// Worker 1: scipy만 (가벼움) - normality_test, descriptive_stats, outlier_detection\n// Worker 2: scipy + statsmodels (중간) - t-tests, chi-square, correlation\n// Worker 3: scikit-learn (무거움) - nonparametric + ANOVA + post-hoc\n// Worker 4: scikit-learn (무거움) - regression + PCA + factor + cluster",
          "keywords": [
            "3-layer",
            "mapping",
            "callWorkerMethod",
            "Worker"
          ]
        },
        {
          "name": "Worker 선택 최적화",
          "purpose": "가벼운 함수는 Worker 1/2, 무거운 함수는 Worker 3/4 사용",
          "code": "// Worker 로딩 시간 차이 (scikit-learn 여부)\n//\n// Worker 1: scipy only       → ~2초  (기본 통계)\n// Worker 2: scipy+statsmodels → ~3초  (가설 검정)\n// Worker 3: +scikit-learn    → ~8초  (비모수 + ANOVA)\n// Worker 4: +scikit-learn    → ~8초  (회귀 + 고급)\n//\n// 최적화 원칙:\n// - 간단한 통계 (평균, 정규성, 이상치) → Worker 1\n// - 가설 검정 (t-test, chi-square)    → Worker 2\n// - 비모수 + ANOVA                    → Worker 3\n// - 회귀 + 고급 분석                  → Worker 4\n\n// ✅ 올바른 Worker 선택\nawait this.ensureWorker1Loaded()  // scipy만 필요한 함수\nreturn this.callWorkerMethod(1, 'descriptive_stats', { data })\n\n// ❌ 잘못된 Worker 선택 (불필요하게 무거운 Worker 사용)\nawait this.ensureWorker4Loaded()  // scikit-learn 불필요한데 Worker 4 사용\nreturn this.callWorkerMethod(4, 'descriptive_stats', { data })",
          "keywords": [
            "optimization",
            "Worker 선택",
            "scikit-learn",
            "로딩 시간"
          ]
        },
        {
          "name": "함수명 규칙 (snake_case)",
          "purpose": "Python Worker 함수명은 snake_case 사용 필수",
          "code": "// Python Worker 함수명 규칙\n//\n// ✅ 올바른 함수명 (snake_case)\n// def t_test_two_sample(group1, group2):\n// def chi_square_test(observed, expected):\n// def one_way_anova(groups):\n//\n// ❌ 잘못된 함수명\n// def tTestTwoSample()  // camelCase 금지\n// def TwoSampleTTest()  // PascalCase 금지\n// def two-sample-ttest()  // kebab-case 금지\n//\n// TypeScript 메서드명 → Python 함수명 매핑\n// twoSampleTTest()    → t_test_two_sample\n// chiSquareTest()     → chi_square_test\n// oneWayANOVA()       → one_way_anova\n// simpleLinearRegression() → linear_regression",
          "keywords": [
            "snake_case",
            "naming convention",
            "함수명"
          ]
        },
        {
          "name": "파라미터 시그니처 매핑 테이블 (2025-11-27)",
          "purpose": "TypeScript → Python 파라미터 키 매핑 (수정 완료된 최신 상태)",
          "code": "// === 파라미터 시그니처 매핑 테이블 ===\n// 파일: __tests__/pyodide/worker-function-mapping.test.ts\n// 마지막 업데이트: 2025-11-27 (2차 수정)\n\n// ┌─────────────────────────────────────────────────────────────────────┐\n// │ Worker 1 (scipy only)                                               │\n// ├─────────────────────────────────────────────────────────────────────┤\n// │ TypeScript 메서드      │ Python 함수              │ 파라미터 키      │\n// ├─────────────────────────────────────────────────────────────────────┤\n// │ shapiroWilkTest()     │ normality_test           │ data             │\n// │ descriptiveStats()    │ descriptive_stats        │ data             │\n// │ outlierDetection()    │ outlier_detection        │ data, method     │\n// │ cronbachAlpha()       │ cronbach_alpha           │ items_matrix  ⭐ │\n// │ oneSampleProportionTest() │ one_sample_proportion_test │ success_count, total_count, null_proportion ⭐ │\n// │ performBonferroni()   │ bonferroni_correction    │ pValues, alpha  │\n// └─────────────────────────────────────────────────────────────────────┘\n\n// ┌─────────────────────────────────────────────────────────────────────┐\n// │ Worker 2 (scipy + statsmodels)                                      │\n// ├─────────────────────────────────────────────────────────────────────┤\n// │ twoSampleTTest()      │ t_test_two_sample        │ group1, group2, equal_var │\n// │ pairedTTest()         │ t_test_paired            │ group1, group2   │\n// │ oneSampleTTest()      │ t_test_one_sample        │ data, popmean ⭐⭐ │\n// │ zTestWorker()         │ z_test                   │ data, popmean, popstd ⭐⭐ │\n// │ partialCorrelationWorker() │ partialCorrelation │ data_matrix, x_idx, y_idx, control_indices ⭐⭐ │\n// │ leveneTest()          │ levene_test              │ groups           │\n// └─────────────────────────────────────────────────────────────────────┘\n\n// ┌─────────────────────────────────────────────────────────────────────┐\n// │ Worker 3 (ANOVA + Post-hoc + Nonparametric)                         │\n// ├─────────────────────────────────────────────────────────────────────┤\n// │ oneWayANOVA()         │ one_way_anova            │ groups           │\n// │ twoWayAnova()         │ two_way_anova            │ data_values, factor1_values, factor2_values │\n// │ repeatedMeasuresAnovaWorker() │ repeated_measures_anova │ data_matrix, subject_ids, time_labels │\n// │ ancovaWorker()        │ ancova                   │ y_values, groupValues, covariates │\n// │ manovaWorker()        │ manova                   │ data_matrix, groupValues, var_names │\n// │ mcnemarTestWorker()   │ mcnemar_test             │ contingency_table ⭐⭐ │\n// │ tukeyHSD()            │ tukey_hsd                │ groups           │\n// │ scheffeTestWorker()   │ scheffe_test             │ groups           │\n// │ gamesHowellTest()     │ games_howell_test        │ groups           │\n// └─────────────────────────────────────────────────────────────────────┘\n\n// ┌─────────────────────────────────────────────────────────────────────┐\n// │ Worker 4 (Regression + Advanced)                                    │\n// ├─────────────────────────────────────────────────────────────────────┤\n// │ simpleLinearRegression() │ linear_regression     │ x, y             │\n// │ multipleRegression()  │ multiple_regression      │ X, y          ⭐ │\n// │ logisticRegression()  │ logistic_regression      │ X, y          ⭐ │\n// │ pca()                 │ pca_analysis             │ data, n_components │\n// │ factorAnalysis()      │ factor_analysis          │ data, n_factors  │\n// │ clusterAnalysis()     │ cluster_analysis         │ data, num_clusters ⭐ │\n// └─────────────────────────────────────────────────────────────────────┘\n\n// ⭐ = 2025-11-27 1차 수정 (6개)\n// ⭐⭐ = 2025-11-27 2차 수정 (4개 추가)\n//\n// 1차 수정 내역:\n// 1. descriptiveStats: group_by 파라미터 제거\n// 2. cronbachAlpha: data → items_matrix\n// 3. oneSampleProportionTest: successes/trials/hypothesized_prop → success_count/total_count/null_proportion\n// 4. multipleRegression: (y, x) → (X, y)\n// 5. logisticRegression: (y, x) → (X, y)\n// 6. clusterAnalysis: n_clusters → num_clusters\n//\n// 2차 수정 내역:\n// 7. oneSampleTTest: test_value → popmean\n// 8. zTestWorker: test_value/population_std → popmean/popstd\n// 9. partialCorrelationWorker: x/y/control_vars → data_matrix/x_idx/y_idx/control_indices (API 재설계)\n// 10. mcnemarTestWorker: table_cells → contingency_table",
          "keywords": [
            "parameter",
            "signature",
            "mapping",
            "파라미터",
            "매핑",
            "테이블",
            "2025-11-27"
          ]
        },
        {
          "name": "TypeScript ↔ Python 파라미터 네이밍 규칙",
          "purpose": "파라미터 이름 변환 규칙 및 주의사항",
          "code": "// === TypeScript ↔ Python 파라미터 네이밍 규칙 ===\n\n// 1. 기본 규칙: snake_case 직통 (변환하지 않음!)\n// ────────────────────────────────────────────────\n// TypeScript에서 callWorkerMethod로 보내는 키 이름이\n// Python 함수 파라미터 이름과 정확히 일치해야 함\n\n// ✅ 올바른 사용\nthis.callWorkerMethod(3, 'two_way_anova', {\n  data_values: dataValues,      // snake_case 직통\n  factor1_values: factor1Values,\n  factor2_values: factor2Values\n})\n\n// ❌ 잘못된 사용 (camelCase로 보내면 Python에서 인식 못함)\nthis.callWorkerMethod(3, 'two_way_anova', {\n  dataValues: dataValues,       // ❌ Python: data_values 기대\n  factor1Values: factor1Values, // ❌ Python: factor1_values 기대\n})\n\n\n// 2. 대소문자 주의 (대문자 파라미터)\n// ────────────────────────────────────────────────\n// 일부 Python 함수는 대문자 파라미터를 사용\n\n// ✅ multiple_regression, logistic_regression\nthis.callWorkerMethod(4, 'multiple_regression', {\n  X: features,  // 대문자 X (feature matrix)\n  y: target     // 소문자 y (target vector)\n})\n\n// ❌ 잘못된 사용\nthis.callWorkerMethod(4, 'multiple_regression', {\n  x: features,  // ❌ Python은 대문자 X 기대\n  Y: target     // ❌ Python은 소문자 y 기대\n})\n\n\n// 3. 자주 틀리는 파라미터 이름\n// ────────────────────────────────────────────────\n// │ 틀린 이름           │ 올바른 이름              │\n// ├─────────────────────────────────────────────────┤\n// │ data               │ items_matrix (cronbach)   │\n// │ successes          │ success_count (proportion)│\n// │ trials             │ total_count (proportion)  │\n// │ hypothesized_prop  │ null_proportion          │\n// │ n_clusters         │ num_clusters (cluster)    │\n// │ x (regression)     │ X (대문자)                │\n// │ test_value         │ popmean (t-test, z-test)  │\n// │ population_std     │ popstd (z-test)           │\n// │ x, y, control_vars │ data_matrix, x_idx, y_idx, control_indices (partial corr) │\n// │ table_cells        │ contingency_table (mcnemar) │\n\n\n// 4. 파라미터 검증 테스트\n// ────────────────────────────────────────────────\n// 파일: __tests__/pyodide/worker-function-mapping.test.ts\n// 테스트: \"파라미터 시그니처 검증\" 섹션 (13개 테스트)\n\n// 검증 항목:\n// - Python 함수 파라미터 이름 추출 (def func(param1, param2):)\n// - TypeScript 서비스의 callWorkerMethod 키 추출\n// - 필수 파라미터 존재 여부\n// - 파라미터 개수 최소 조건",
          "keywords": [
            "naming",
            "convention",
            "snake_case",
            "camelCase",
            "변환",
            "주의사항"
          ]
        },
        {
          "name": "매핑 검증 테스트 추가 방법",
          "purpose": "새 함수 추가 시 EXPECTED_MAPPINGS에 등록",
          "code": "// 새 Worker 메서드 추가 시 EXPECTED_MAPPINGS 업데이트 필수!\n// 파일: __tests__/pyodide/worker-function-mapping.test.ts\n\nconst EXPECTED_MAPPINGS = [\n  // ... 기존 매핑 ...\n\n  // 새로 추가하는 함수\n  {\n    worker: 3,                    // Python Worker 번호 (1-4)\n    function: 'dunn_test',        // Python 함수명 (snake_case)\n    tsMethod: 'dunnTestWorker'    // TypeScript 메서드명 (camelCase)\n  },\n]\n\n// 양방향 동기화로 자동 감지:\n// 1. 서비스에 메서드 추가 → 테스트 실패 → EXPECTED_MAPPINGS에 추가\n// 2. 서비스에서 메서드 삭제 → 테스트 실패 → EXPECTED_MAPPINGS에서 제거\n// 3. Python에 함수 없음 → 테스트 실패 → Python Worker에 함수 구현",
          "keywords": [
            "EXPECTED_MAPPINGS",
            "테스트",
            "새 함수 추가"
          ]
        },
        {
          "name": "현재 Worker별 함수 목록",
          "purpose": "2025-11-27 기준 Worker별 함수 배치",
          "code": "// Worker 1 (scipy only - 가벼움)\n// - normality_test       (shapiroWilkTest)\n// - descriptive_stats    (descriptiveStats)\n// - outlier_detection    (outlierDetection)\n// - cronbach_alpha       (cronbachAlpha)\n// - one_sample_proportion_test (oneSampleProportionTest)\n// - bonferroni_correction (performBonferroni)\n\n// Worker 2 (scipy + statsmodels - 중간)\n// - t_test_two_sample    (twoSampleTTest)\n// - t_test_paired        (pairedTTest)\n// - t_test_one_sample    (oneSampleTTest)\n// - z_test               (zTestWorker)\n// - chi_square_test      (chiSquareTest)\n// - binomial_test        (binomialTestWorker)\n// - correlation_test     (correlationTest)\n// - partialCorrelation  (partialCorrelationWorker)\n// - levene_test          (leveneTest)\n\n// Worker 3 (scikit-learn - 무거움, 비모수 + ANOVA)\n// - mann_whitney_test, wilcoxon_test, kruskal_wallis_test\n// - friedman_test, sign_test, runs_test, mcnemar_test\n// - cochran_q_test, mood_median_test\n// - one_way_anova, two_way_anova, repeated_measures_anova\n// - ancova, manova\n// - tukey_hsd, scheffe_test, games_howell_test\n\n// Worker 4 (scikit-learn - 무거움, 회귀 + 고급)\n// - linear_regression, multiple_regression, logistic_regression\n// - pca_analysis, factor_analysis, cluster_analysis",
          "keywords": [
            "Worker 목록",
            "함수 배치",
            "현재 상태"
          ]
        },
        {
          "name": "검증 테스트 요약 (Verification Summary)",
          "purpose": "Worker 매핑 테스트가 검증하는 항목 일람",
          "code": "// Worker-Function 매핑 검증 테스트 (321개)\n// 파일: __tests__/pyodide/worker-function-mapping.test.ts\n\n// ┌─────────────────────────────────────────────────────────┐\n// │ 검증 항목                    │ 테스트 수 │ 자동 감지   │\n// ├─────────────────────────────────────────────────────────┤\n// │ 1. 함수 존재 여부            │ 38개     │ ✅ Python에 │\n// │    - Python Worker에 함수가 있는지                      │\n// │                                                         │\n// │ 2. Worker 번호               │ 4개      │ ✅ 최적화   │\n// │    - 올바른 Worker를 호출하는지                         │\n// │                                                         │\n// │ 3. 양방향 동기화             │ 2개      │ ✅ 추가/삭제│\n// │    - 서비스 ↔ EXPECTED_MAPPINGS 일치                    │\n// │                                                         │\n// │ 4. 파라미터 시그니처          │ 13개     │ ✅ TypeError│\n// │    - 파라미터 이름 일치 (camelCase)                     │\n// │    - 필수 파라미터 개수                                 │\n// │    - 서비스가 보내는 키 vs Python 기대 파라미터         │\n// │                                                         │\n// │ 5. Registry ↔ Python 자동 동기화 │ 260+개 │ ✅ Phase2  │\n// │    - 레지스트리 메서드 → Python 존재 여부               │\n// │    - 레지스트리 파라미터 → Python 일치 여부             │\n// │    - Python 파라미터 → 레지스트리 누락 여부             │\n// │    - 파라미터 명명 규칙 (camelCase) 검증                │\n// └─────────────────────────────────────────────────────────┘\n\n// 검증되지 않는 항목 (런타임에서만 확인 가능):\n// - 파라미터 타입 (number[] vs string[])\n// - 실제 Python 함수 실행 결과\n// - 반환값 구조",
          "keywords": [
            "verification",
            "summary",
            "검증",
            "테스트 목록",
            "61개"
          ]
        },
        {
          "name": "상위 계층 참조 (Analysis Flow)",
          "purpose": "Worker가 호출되는 전체 흐름 참조",
          "code": "// Worker는 전체 분석 흐름의 5번째 계층입니다.\n// 전체 흐름을 이해하려면 \"Analysis Flow Architecture\" 카테고리 참조\n\n// UI → Executor → Service → Core → Worker (여기)\n//\n// 상위 계층에서 Worker 호출하는 방법:\n//\n// 1. Executor (statistical-executor.ts)\n//    const stats = await pyodideStats.descriptiveStats(values)\n//\n// 2. Service (pyodide-statistics.ts)\n//    return this.core.callWorkerMethod(1, 'descriptive_stats', { data })\n//\n// 3. Core (pyodide-core.service.ts)\n//    await this.ensureWorker1Loaded()\n//    const result = this.pyodide.runPythonAsync(`descriptive_stats(**params)`)\n//\n// 4. Worker (worker1-descriptive.py)\n//    def descriptive_stats(data):\n//        return { 'mean': np.mean(data), 'std': np.std(data), ... }",
          "keywords": [
            "cross-reference",
            "상위 계층",
            "Analysis Flow"
          ]
        }
      ]
    },
    {
      "name": "Analysis Flow Architecture",
      "description": "통계 분석 실행 흐름 전체 아키텍처 (UI → Executor → Service → Worker)",
      "patterns": [
        {
          "name": "전체 분석 흐름 (End-to-End Flow)",
          "purpose": "UI 컴포넌트부터 Python Worker까지 전체 데이터 흐름 이해",
          "code": "// === 통계 분석 실행 흐름 (5계층) ===\n//\n// ┌─────────────────────────────────────────────────────────────────┐\n// │ 1. UI Layer (React Components)                                  │\n// │    app/(dashboard)/methods/t-test/page.tsx                     │\n// │    └─ useStatisticsPage() hook 사용                            │\n// │    └─ handleAnalyze() → StatisticalExecutor.executeMethod()    │\n// └─────────────────────────────────────────────────────────────────┘\n//                              ↓\n// ┌─────────────────────────────────────────────────────────────────┐\n// │ 2. Executor Layer (비즈니스 로직)                               │\n// │    lib/services/statistical-executor.ts                        │\n// │    └─ executeMethod(method, data, variables)                   │\n// │    └─ prepareData() → 변수 추출 및 그룹화                       │\n// │    └─ executeTTest() / executeANOVA() 등 카테고리별 분기        │\n// └─────────────────────────────────────────────────────────────────┘\n//                              ↓\n// ┌─────────────────────────────────────────────────────────────────┐\n// │ 3. Service Layer (Python 호출 래퍼)                             │\n// │    lib/services/pyodide-statistics.ts                          │\n// │    └─ pyodideStats.tTest() / .anova() / .correlation()         │\n// │    └─ 내부적으로 PyodideCoreService.callWorkerMethod() 호출     │\n// └─────────────────────────────────────────────────────────────────┘\n//                              ↓\n// ┌─────────────────────────────────────────────────────────────────┐\n// │ 4. Core Service Layer (Worker 관리)                             │\n// │    lib/services/pyodide/core/pyodide-core.service.ts           │\n// │    └─ callWorkerMethod<T>(workerNum, funcName, params)         │\n// │    └─ ensureWorker1/2/3/4Loaded() → 필요 시 Worker 로딩         │\n// │    └─ Python 코드 실행 및 결과 파싱                             │\n// └─────────────────────────────────────────────────────────────────┘\n//                              ↓\n// ┌─────────────────────────────────────────────────────────────────┐\n// │ 5. Python Worker Layer (실제 계산)                              │\n// │    public/workers/python/worker1~4-*.py                        │\n// │    └─ def t_test_two_sample(group1, group2, ...)               │\n// │    └─ SciPy/statsmodels/scikit-learn 사용                      │\n// │    └─ JSON 결과 반환                                            │\n// └─────────────────────────────────────────────────────────────────┘",
          "keywords": [
            "architecture",
            "flow",
            "5-layer",
            "전체 흐름",
            "아키텍처"
          ]
        },
        {
          "name": "Executor 계층 상세",
          "purpose": "StatisticalExecutor의 역할과 카테고리별 분기 이해",
          "code": "// === StatisticalExecutor ===\n// 파일: lib/services/statistical-executor.ts\n// 역할: UI와 Python Worker 사이의 중간 계층 (비즈니스 로직)\n\nclass StatisticalExecutor {\n  // Singleton 패턴\n  static getInstance(): StatisticalExecutor\n\n  // 메인 실행 메서드\n  async executeMethod(\n    method: StatisticalMethod,    // 분석 메서드 정보 (id, name, category)\n    data: any[],                  // 원본 데이터 (업로드된 행 배열)\n    variables: {                  // 변수 역할 매핑\n      dependent?: string[]        // 종속변수\n      independent?: string[]      // 독립변수\n      group?: string              // 그룹변수\n      time?: string               // 시간변수\n      covariate?: string[]        // 공변량 (ANCOVA)\n      within?: string[]           // 피험자내 요인 (반복측정)\n      between?: string[]          // 피험자간 요인 (혼합모형)\n    }\n  ): Promise<AnalysisResult>\n\n  // 카테고리별 분기 (switch-case)\n  switch (method.category) {\n    case 'descriptive':   → executeDescriptive()\n    case 't-test':        → executeTTest()\n    case 'anova':         → executeANOVA()\n    case 'regression':    → executeRegression()\n    case 'correlation':   → executeCorrelation()\n    case 'nonparametric': → executeNonparametric()\n    case 'chi-square':    → executeChiSquare()\n    case 'pca':           → executeMultivariate()\n    case 'timeseries':    → executeTimeSeries()\n    case 'psychometrics': → executeReliability()\n    case 'survival':      → executeSurvival()\n  }\n}\n\n// 데이터 준비 (prepareData)\n// - 종속/독립변수 추출 → arrays.dependent, arrays.independent\n// - 그룹변수로 데이터 분할 → arrays.byGroup\n// - 공변량/피험자내/피험자간 요인 추출",
          "keywords": [
            "Executor",
            "executeMethod",
            "prepareData",
            "category",
            "switch"
          ]
        },
        {
          "name": "Executor 라우팅 테이블 (Category → Executor)",
          "purpose": "메서드 카테고리별 Executor 분기 규칙 및 테스트 검증 방법",
          "code": "// === Executor 라우팅 테이블 ===\n// 파일: lib/services/statistical-executor.ts (Line 115-156)\n// 업데이트: 2025-11-27\n\n// StatisticalExecutor.executeMethod() 내부 switch-case 분기:\n\n// ┌────────────────────────────────────────────────────────────────────────┐\n// │ Category       │ Executor Method         │ Executor 파일               │\n// ├────────────────────────────────────────────────────────────────────────┤\n// │ descriptive    │ executeDescriptive()    │ descriptive-executor.ts     │\n// │ t-test         │ executeTTest()          │ t-test-executor.ts          │\n// │ anova          │ executeANOVA()          │ anova-executor.ts           │\n// │ regression     │ executeRegression()     │ regression-executor.ts      │\n// │ correlation    │ executeCorrelation()    │ correlation-executor.ts  ⭐⭐ │\n// │ nonparametric  │ executeNonparametric()  │ nonparametric-executor.ts   │\n// │ chi-square     │ executeChiSquare()      │ (inline 구현)               │\n// │ pca/clustering │ executeMultivariate()   │ advanced-executor.ts        │\n// │ advanced       │ executeMultivariate()   │ advanced-executor.ts        │\n// │ timeseries     │ executeTimeSeries()     │ (inline 구현)               │\n// │ psychometrics  │ executeReliability()    │ (inline 구현)               │\n// │ survival       │ executeSurvival()       │ (inline 구현)               │\n// │ design         │ executeDesign()         │ (inline 구현)               │\n// └────────────────────────────────────────────────────────────────────────┘\n\n// ⭐⭐ = 2025-11-27 correlation-executor.ts 신규 생성 + 버그 수정\n//      (Pearson 상관분석 선택 시 기술통계 결과 출력 문제 해결)\n\n// === 라우팅 흐름 ===\n// 1. UI에서 method 객체 전달 (id, name, category 포함)\n// 2. StatisticalExecutor.executeMethod(method, data, variables)\n// 3. switch (method.category) → 해당 execute*() 메서드 호출\n// 4. Executor 내부에서 PyodideCoreService.callWorkerMethod() 호출\n\n// === 라우팅 테스트 ===\n// 파일: __tests__/services/executors/statistical-executor-routing.test.ts\n// 검증: 각 메서드 ID가 올바른 category로 라우팅되는지 확인\n\ndescribe('Statistical Executor Routing', () => {\n  it('pearson-correlation → correlation category', () => {\n    const method = STATISTICAL_METHODS.find(m => m.id === 'pearson-correlation')\n    expect(method?.category).toBe('correlation')\n  })\n\n  it('independent-t-test → t-test category', () => {\n    const method = STATISTICAL_METHODS.find(m => m.id === 'independent-t-test')\n    expect(method?.category).toBe('t-test')\n  })\n})",
          "keywords": [
            "routing",
            "라우팅",
            "category",
            "Executor",
            "switch-case",
            "분기"
          ]
        },
        {
          "name": "Executor 라우팅 버그 및 해결 방법",
          "purpose": "자주 발생하는 라우팅 버그와 디버깅 방법",
          "code": "// === 자주 발생하는 라우팅 버그 ===\n\n// 버그 1: 잘못된 결과 출력 (예: Pearson → 기술통계)\n// ────────────────────────────────────────────────\n// 증상: 특정 분석 선택 시 다른 분석 결과가 출력됨\n// 원인:\n//   1. method.category가 잘못 설정됨\n//   2. switch-case에서 해당 category 누락 (default로 빠짐)\n//   3. 불완전한 라우터 파일 존재 (중복 StatisticalExecutor)\n\n// 디버깅 방법:\nconsole.log('Method:', method.id)\nconsole.log('Category:', method.category)\n// → category가 undefined이거나 예상과 다르면 STATISTICAL_METHODS 확인\n\n// 해결:\n// 1. lib/constants/statistical-methods.ts에서 해당 method의 category 확인\n// 2. statistical-executor.ts switch-case에 해당 category 존재 확인\n// 3. 중복 파일 제거 (lib/services/executors/statistical-executor.ts 삭제)\n\n\n// 버그 2: \"지원되지 않는 분석 카테고리\" 에러\n// ────────────────────────────────────────────────\n// 증상: Error: 지원되지 않는 분석 카테고리: xxx\n// 원인: switch-case에 해당 category가 없음\n\n// 해결:\n// statistical-executor.ts에 새 case 추가:\nswitch (method.category) {\n  // ... 기존 case ...\n  case 'new-category':\n    result = await this.executeNewCategory(method, preparedData)\n    break\n}\n\n\n// 버그 3: Executor 파일 충돌\n// ────────────────────────────────────────────────\n// 증상: import 경로에 따라 다른 구현이 로드됨\n// 원인: 같은 이름의 Executor가 여러 위치에 존재\n\n// 확인 방법:\n// find . -name \"*executor*.ts\" -type f\n\n// 파일 구조 (올바른 구조):\n// lib/services/\n// ├── statistical-executor.ts          ← 메인 라우터 (유일해야 함)\n// └── executors/\n//     ├── base-executor.ts             ← 추상 클래스\n//     ├── descriptive-executor.ts\n//     ├── t-test-executor.ts\n//     ├── anova-executor.ts\n//     ├── regression-executor.ts\n//     ├── correlation-executor.ts      ← 2025-11-27 추가\n//     ├── nonparametric-executor.ts\n//     └── advanced-executor.ts",
          "keywords": [
            "bug",
            "버그",
            "디버깅",
            "debugging",
            "라우팅 오류"
          ]
        },
        {
          "name": "Service 계�� (pyodide-statistics.ts)",
          "purpose": "Python Worker 호출 래퍼 레이어 이해",
          "code": "// === pyodide-statistics.ts ===\n// 파일: lib/services/pyodide-statistics.ts\n// 역할: TypeScript에서 Python 함수를 호출하기 위한 래퍼\n\n// ⚠️ 주의사항 (파일 상단 주석)\n// - 새 메서드를 이 파일에 직접 구현하지 말 것!\n// - Python Worker 파일에 함수 추가 후 래퍼만 추가\n\n// 예시: tTest 메서드\nasync tTest(group1: number[], group2: number[], options?) {\n  // 내부적으로 PyodideCoreService 호출\n  return this.core.callWorkerMethod<StatisticsResult>(\n    2,                    // Worker 2 (hypothesis)\n    't_test_two_sample',  // Python 함수명\n    { group1, group2, equal_var: options?.equalVar }\n  )\n}\n\n// pyodideStats 싱글톤 인스턴스\nexport const pyodideStats = PyodideStatistics.getInstance()\n\n// 사용 예시 (Executor에서)\nconst result = await pyodideStats.tTest(group1, group2, { paired: false })\nconst stats = await pyodideStats.descriptiveStats(values)\nconst anova = await pyodideStats.anova(groups, { type: 'one-way' })",
          "keywords": [
            "pyodide-statistics",
            "wrapper",
            "래퍼",
            "pyodideStats"
          ]
        },
        {
          "name": "PyodideCoreService (Worker 관리)",
          "purpose": "Python Worker 로딩 및 호출 메커니즘 이해",
          "code": "// === PyodideCoreService ===\n// 파일: lib/services/pyodide/core/pyodide-core.service.ts\n// 역할: Pyodide 인스턴스 관리 + Worker 로딩 + 메서드 호출\n\nclass PyodideCoreService {\n  // Singleton 패턴\n  private static instance: PyodideCoreService\n\n  // 핵심 메서드: Worker 함수 호출\n  async callWorkerMethod<T>(\n    workerNum: number,           // Worker 번호 (1-4)\n    funcName: string,            // Python 함수명 (snake_case)\n    params: Record<string, any>  // 파라미터 객체\n  ): Promise<T> {\n    // 1. Worker 로딩 확인\n    await this.ensureWorkerLoaded(workerNum)\n\n    // 2. Python 함수 호출\n    const pythonCode = `\n      import json\n      result = ${funcName}(**${JSON.stringify(params)})\n      json.dumps(result)\n    `\n\n    // 3. 결과 파싱 및 반환\n    const result = await this.pyodide.runPythonAsync(pythonCode)\n    return JSON.parse(result) as T\n  }\n\n  // Worker 로딩 (Lazy Loading)\n  private async ensureWorkerLoaded(workerNum: number) {\n    if (this.loadedWorkers.has(workerNum)) return\n\n    const workerCode = await fetch(`/workers/python/worker${workerNum}-*.py`)\n    await this.pyodide.runPythonAsync(workerCode)\n    this.loadedWorkers.add(workerNum)\n  }\n}\n\n// Worker 파일 구성\n// Worker 1: scipy only      (worker1-descriptive.py)      ~2초\n// Worker 2: statsmodels     (worker2-hypothesis.py)       ~3초\n// Worker 3: scikit-learn    (worker3-nonparametric.py)    ~8초\n// Worker 4: scikit-learn    (worker4-regression.py)       ~8초",
          "keywords": [
            "PyodideCoreService",
            "callWorkerMethod",
            "Worker",
            "Lazy Loading"
          ]
        },
        {
          "name": "Python Worker 파일 구조",
          "purpose": "Python Worker 파일의 함수 구조 이해",
          "code": "// === Python Worker 파일 ===\n// 위치: public/workers/python/worker*.py\n\n# worker2-hypothesis.py 예시\nimport numpy as np\nfrom scipy import stats\n\ndef t_test_two_sample(group1, group2, equal_var=True, alternative='two-sided'):\n    \"\"\"\n    독립표본 t-검정 (Two-sample t-test)\n\n    Parameters:\n    -----------\n    group1 : list[float]\n        첫 번째 그룹 데이터\n    group2 : list[float]\n        두 번째 그룹 데이터\n    equal_var : bool\n        등분산 가정 (True: Student's t, False: Welch's t)\n    alternative : str\n        대립가설 방향 ('two-sided', 'less', 'greater')\n\n    Returns:\n    --------\n    dict\n        {\n            'tStatistic': float,\n            'pValue': float,\n            'df': float,\n            'mean1': float,\n            'mean2': float,\n            'cohen_d': float\n        }\n    \"\"\"\n    arr1 = np.array(group1)\n    arr2 = np.array(group2)\n\n    result = stats.ttest_ind(arr1, arr2, equal_var=equal_var, alternative=alternative)\n\n    # Cohen's d 계산\n    pooled_std = np.sqrt(((len(arr1)-1)*arr1.std(ddof=1)**2 +\n                          (len(arr2)-1)*arr2.std(ddof=1)**2) /\n                         (len(arr1) + len(arr2) - 2))\n    cohen_d = (arr1.mean() - arr2.mean()) / pooled_std\n\n    return {\n        'tStatistic': float(result.statistic),\n        'pValue': float(result.pvalue),\n        'df': float(len(arr1) + len(arr2) - 2),\n        'mean1': float(arr1.mean()),\n        'mean2': float(arr2.mean()),\n        'cohen_d': float(cohen_d)\n    }\n\n# 함수명 규칙: snake_case\n# 파라미터: snake_case\n# 반환값: dict → JSON 직렬화",
          "keywords": [
            "Python Worker",
            "snake_case",
            "SciPy",
            "statsmodels"
          ]
        },
        {
          "name": "BaseExecutor (공통 유틸리티)",
          "purpose": "Executor 공통 기능 (데이터 추출, 에러 처리, 해석)",
          "code": "// === BaseExecutor ===\n// 파일: lib/services/executors/base-executor.ts\n// 역할: 모든 Executor의 공통 기능 제공\n\nabstract class BaseExecutor {\n  // 공통 유틸리티\n\n  // 1. p-value 해석\n  protected interpretPValue(pvalue: number): string {\n    if (pvalue < 0.001) return '매우 강한 통계적 유의성 (p < 0.001)'\n    if (pvalue < 0.01)  return '강한 통계적 유의성 (p < 0.01)'\n    if (pvalue < 0.05)  return '통계적으로 유의 (p < 0.05)'\n    if (pvalue < 0.1)   return '약한 통계적 유의성 (p < 0.1)'\n    return '통계적으로 유의하지 않음 (p ≥ 0.05)'\n  }\n\n  // 2. 효과크기 해석\n  protected interpretEffectSize(d: number, type: 'cohen' | 'eta' | 'omega'): string {\n    if (type === 'cohen') {\n      if (d < 0.2) return '무시할 수준'\n      if (d < 0.5) return '작은 효과'\n      if (d < 0.8) return '중간 효과'\n      return '큰 효과'\n    }\n    // eta-squared, omega-squared\n    if (d < 0.01) return '무시할 수준'\n    if (d < 0.06) return '작은 효과'\n    if (d < 0.14) return '중간 효과'\n    return '큰 효과'\n  }\n\n  // 3. 수치형 데이터 추출 (객체 배열 → 숫자 배열)\n  protected extractNumericSeries(data: unknown[], options?: unknown): number[] {\n    // - 이미 숫자 배열이면 그대로 반환\n    // - 객체 배열이면 variables 옵션에서 컬럼명 추출\n    // - null/undefined/''/NaN 필터링\n  }\n\n  // 4. 메타데이터 생성\n  protected createMetadata(method: string, dataSize: number, startTime: number)\n\n  // 5. 에러 처리\n  protected handleError(error: unknown, method: string): AnalysisResult\n\n  // 추상 메서드 (각 Executor가 구현)\n  abstract execute(data: unknown[], options?: unknown): Promise<AnalysisResult>\n}",
          "keywords": [
            "BaseExecutor",
            "interpretPValue",
            "extractNumericSeries",
            "공통 유틸"
          ]
        },
        {
          "name": "Executor 라우팅 테스트 패턴",
          "purpose": "StatisticalExecutor 라우팅이 올바른지 검증하는 테스트 작성법",
          "code": "// === Executor 라우팅 테스트 ===\n// 파일: __tests__/services/executors/statistical-executor-routing.test.ts\n// 목적: 메서드 ID → category → Executor 라우팅 검증\n// 관련 버그: Pearson 상관분석 → 기술통계 출력 (2025-11-27 수정)\n\n// 1. Pyodide Mock 설정\njest.mock('@/lib/services/pyodide-statistics', () => ({\n  pyodideStats: {\n    isReady: true,\n    initialize: jest.fn().mockResolvedValue(undefined),\n    correlationTest: jest.fn().mockResolvedValue({ correlation: 0.85, pValue: 0.001 }),\n    correlation: jest.fn().mockResolvedValue({\n      pearson: { r: 0.85, pValue: 0.001 },\n      spearman: { r: 0.82, pValue: 0.002 },\n      kendall: { tau: 0.72, pValue: 0.005 }\n    }),\n    // ... 다른 메서드 mock\n  }\n}))\n\n// 2. StatisticalMethod 헬퍼\nconst createMethod = (id: string, name: string, category: StatisticalMethod['category']): StatisticalMethod => ({\n  id,\n  name,\n  description: `Test ${name}`,\n  category,\n  requirements: { minSampleSize: 3, variableTypes: ['numeric'] }\n})\n\n// 3. 라우팅 테스트 예시\ndescribe('Category: correlation', () => {\n  it('should route \"pearson-correlation\" to CorrelationExecutor', async () => {\n    const result = await executor.executeMethod(\n      createMethod('pearson-correlation', 'Pearson', 'correlation'),\n      mockData,\n      { dependentVar: 'x', independentVar: 'y' }\n    )\n\n    expect(result).toBeDefined()\n    expect(result.metadata.method).toBeDefined()\n    expect(result.metadata.method).not.toContain('기술통계')  // 버그 검증!\n  })\n})\n\n// 4. 핵심 검증 항목\n// - result.metadata.method가 예상 분석 타입을 포함하는지\n// - 다른 분석 타입(기술통계 등)을 포함하지 않는지\n// - Error 없이 실행되는지",
          "keywords": [
            "routing test",
            "라우팅 테스트",
            "StatisticalExecutor",
            "category",
            "버그 검증"
          ]
        },
        {
          "name": "AnalysisResult 결과 타입",
          "purpose": "통계 분석 결과의 표준 데이터 구조",
          "code": "// === StatisticalExecutorResult (AnalysisResult) ===\n// 파일: lib/services/statistical-executor.ts\n\ninterface StatisticalExecutorResult {\n  // 1. 메타데이터\n  metadata: {\n    method: string           // 메서드 ID (예: 'two-sample-t')\n    methodName: string       // 표시명 (예: '독립표본 t-검정')\n    timestamp: string        // ISO 8601 (예: '2025-11-27T12:00:00Z')\n    duration: number         // 실행 시간 (초)\n    dataInfo: {\n      totalN: number         // 총 표본 수\n      missingRemoved: number // 제거된 결측값 수\n      groups?: number        // 그룹 수 (해당 시)\n    }\n  }\n\n  // 2. 주 결과\n  mainResults: {\n    statistic: number        // 검정통계량 (t, F, χ², r 등)\n    pvalue: number           // 유의확률\n    df?: number              // 자유도\n    significant: boolean     // 유의 여부 (p < 0.05)\n    interpretation?: string  // 결과 해석 문장\n  }\n\n  // 3. 부가 정보\n  additionalInfo: {\n    effectSize?: {           // 효과크기\n      type: string           // \"Cohen's d\", \"eta-squared\", \"R²\" 등\n      value: number\n      interpretation: string // \"작은 효과\", \"중간 효과\" 등\n    }\n    confidenceInterval?: {   // 신뢰구간\n      level: number          // 95\n      lower: number\n      upper: number\n    }\n    assumptions?: {          // 가정 검정 결과\n      passed: boolean\n      details: any[]\n    }\n    postHoc?: any            // 사후검정 결과 (ANOVA)\n  }\n\n  // 4. 시각화 데이터\n  visualizationData?: {\n    type: string             // 'boxplot', 'histogram', 'scatter' 등\n    data: any                // 차트 렌더링용 데이터\n  }\n\n  // 5. 원시 결과 (디버깅용)\n  rawResults?: any           // Python Worker 원본 반환값\n}",
          "keywords": [
            "AnalysisResult",
            "StatisticalExecutorResult",
            "결과 타입",
            "mainResults"
          ]
        }
      ]
    },
    {
      "name": "Methods Registry Tests",
      "description": "Methods Registry SSOT 검증 테스트 패턴",
      "patterns": [
        {
          "name": "Registry 유틸리티 함수 테스트",
          "purpose": "getWorkerForMethod, methodExists 등 유틸리티 검증",
          "code": "import {\n  getWorkerForMethod,\n  getMethodDefinition,\n  methodExists,\n  getAllMethods\n} from '@/lib/constants/methods-registry.types'\n\ndescribe('Methods Registry', () => {\n  it('Worker 번호를 올바르게 찾아야 함', () => {\n    expect(getWorkerForMethod('t_test_two_sample')).toBe(2)\n    expect(getWorkerForMethod('one_way_anova')).toBe(3)\n    expect(getWorkerForMethod('non_existent')).toBeNull()\n  })\n\n  it('메서드 존재 여부 확인', () => {\n    expect(methodExists('descriptive_stats')).toBe(true)\n    expect(methodExists('fake_method')).toBe(false)\n  })\n\n  it('메서드 정의를 반환해야 함', () => {\n    const def = getMethodDefinition('t_test_two_sample')\n    expect(def?.params).toContain('group1')\n    expect(def?.returns).toContain('pValue')\n  })\n})",
          "keywords": [
            "methods-registry",
            "getWorkerForMethod",
            "methodExists",
            "SSOT"
          ]
        },
        {
          "name": "Registry-Python 동기화 검증",
          "purpose": "Registry의 메서드가 Python Worker에 실제 존재하는지 확인",
          "code": "import { readFileSync } from 'fs'\nimport { getAllMethods, WorkerNumber } from '@/lib/constants/methods-registry.types'\n\nfunction extractPythonFunctions(workerNum: WorkerNumber): string[] {\n  const filePath = `public/workers/python/worker${workerNum}-*.py`\n  const content = readFileSync(filePath, 'utf8')\n  const pattern = /^def ([a-z][a-z0-9_]*)\\(/gm\n  const functions: string[] = []\n  let match\n  while ((match = pattern.exec(content)) !== null) {\n    functions.push(match[1])\n  }\n  return functions\n}\n\ndescribe('Registry SSOT 검증', () => {\n  const allMethods = getAllMethods()\n\n  it.each(allMethods.map(m => [m.methodName, m.workerNum]))(\n    '%s가 Worker %d에 존재해야 함',\n    (methodName, workerNum) => {\n      const pythonFunctions = extractPythonFunctions(workerNum as WorkerNumber)\n      expect(pythonFunctions).toContain(methodName)\n    }\n  )\n})",
          "keywords": [
            "SSOT guardrail",
            "Python sync",
            "extractPythonFunctions",
            "동기화 검증"
          ]
        }
      ]
    },
    {
      "name": "Template System Tests",
      "description": "분석 템플릿 저장/불러오기 테스트 패턴",
      "patterns": [
        {
          "name": "AnalysisTemplate 타입 검증",
          "purpose": "템플릿 구조가 올바른지 확인",
          "code": "import type { AnalysisTemplate, VariableRoleMapping } from '@/types/smart-flow'\n\ndescribe('IndexedDB Templates', () => {\n  describe('AnalysisTemplate 타입', () => {\n    it('올바른 템플릿 구조를 가져야 함', () => {\n      const template: AnalysisTemplate = {\n        id: 'test-1',\n        name: '테스트 템플릿',\n        description: '설명',\n        createdAt: Date.now(),\n        updatedAt: Date.now(),\n        usageCount: 0,\n        lastUsedAt: null,\n        purpose: 'compare',\n        method: {\n          id: 't-test',\n          name: '독립표본 t-검정',\n          category: 't-test'\n        },\n        variableRoles: {\n          dependent: {\n            role: 'dependent',\n            type: 'numeric',\n            description: 'score'\n          }\n        }\n      }\n\n      expect(template.id).toBe('test-1')\n      expect(template.method.category).toBe('t-test')\n    })\n  })\n})",
          "keywords": [
            "AnalysisTemplate",
            "IndexedDB",
            "템플릿 구조"
          ]
        },
        {
          "name": "VariableMapping 변환 테스트",
          "purpose": "string | string[] 타입 안전 변환 검증",
          "code": "describe('VariableMapping -> VariableRoleMapping 변환', () => {\n  // toStringValue 헬퍼 함수 로직 테스트\n  it('string을 그대로 반환해야 함', () => {\n    const value: string | string[] = 'score'\n    const result = Array.isArray(value) ? value[0] : value\n    expect(result).toBe('score')\n  })\n\n  it('string[]의 첫 번째 요소를 반환해야 함', () => {\n    const value: string | string[] = ['score', 'value']\n    const result = Array.isArray(value) ? value[0] : value\n    expect(result).toBe('score')\n  })\n\n  // toArrayValue 헬퍼 함수 로직 테스트\n  it('string을 배열로 감싸야 함', () => {\n    const value: string | string[] = 'single'\n    const result = Array.isArray(value) ? value : [value]\n    expect(result).toEqual(['single'])\n  })\n})",
          "keywords": [
            "toStringValue",
            "toArrayValue",
            "타입 변환",
            "VariableMapping"
          ]
        },
        {
          "name": "변수 자동 매칭 테스트",
          "purpose": "템플릿 역할을 새 데이터 컬럼에 자동 매칭",
          "code": "describe('변수 자동 매칭', () => {\n  it('수치형/범주형 변수를 역할에 매칭해야 함', () => {\n    const roles: VariableRoleMapping = {\n      dependent: { role: 'dependent', type: 'numeric' },\n      independent: { role: 'group', type: 'categorical' }\n    }\n\n    const numericCols = ['score', 'age', 'height']\n    const categoricalCols = ['group', 'gender']\n\n    const matched: Record<string, string> = {}\n    const unmatched: string[] = []\n\n    // 종속변수 매칭\n    if (roles.dependent && numericCols.length > 0) {\n      matched['dependent'] = numericCols[0]\n    }\n\n    // 독립변수 매칭\n    if (roles.independent?.type === 'categorical') {\n      const available = categoricalCols.filter(c => c !== matched['dependent'])\n      if (available.length > 0) matched['independent'] = available[0]\n      else unmatched.push('independent')\n    }\n\n    expect(matched['dependent']).toBe('score')\n    expect(matched['independent']).toBe('group')\n    expect(unmatched).toHaveLength(0)\n  })\n})",
          "keywords": [
            "matchVariables",
            "자동 매칭",
            "numeric",
            "categorical"
          ]
        },
        {
          "name": "IndexedDB Mock 패턴",
          "purpose": "IndexedDB 함수 모킹 방법",
          "code": "// Mock IndexedDB 함수들\njest.mock('@/lib/utils/indexeddb-templates', () => ({\n  isIndexedDBAvailable: jest.fn(() => true),\n  getAllTemplates: jest.fn(async () => []),\n  getTemplate: jest.fn(async () => null),\n  saveTemplate: jest.fn(async () => {}),\n  updateTemplate: jest.fn(async () => {}),\n  deleteTemplate: jest.fn(async () => {}),\n  clearAllTemplates: jest.fn(async () => {}),\n  incrementTemplateUsage: jest.fn(async () => {}),\n  getRecentTemplates: jest.fn(async () => [])\n}))\n\ndescribe('Template Store', () => {\n  it('템플릿 ID가 올바른 형식이어야 함', () => {\n    const id = `template-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`\n    expect(id).toMatch(/^template-\\d+-[a-z0-9]+$/)\n  })\n})",
          "keywords": [
            "jest.mock",
            "IndexedDB",
            "template-store"
          ]
        }
      ]
    },
    {
      "name": "Graph Studio / JSON Patch Tests",
      "description": "RFC 6901/6902 JSON Patch, Zod 스키마 검증, 유틸리티 함수 테스트 패턴",
      "patterns": [
        {
          "name": "RFC 6902 JSON Patch 연산 테스트",
          "purpose": "applyPatches의 add/replace/remove 연산이 RFC 6902 규격을 준수하는지 검증. 배열 인덱스 경계, ~0/~1 이스케이프, -로 append 등 edge case 포함",
          "code": "import { describe, it, expect } from 'vitest';\nimport { applyPatches } from '@/lib/graph-studio/chart-spec-utils';\nimport type { ChartSpec } from '@/types/graph-studio';\n\n// 최소 spec 픽스처\nconst baseSpec: ChartSpec = { /* ... */ };\n\ndescribe('applyPatches — RFC 6901/6902 준수', () => {\n  it('~1 → /, ~0 → ~ 순서대로 언이스케이프', () => {\n    const spec = { ...baseSpec, annotations: [{ id: 'a/b~c', text: 'old' }] };\n    const result = applyPatches(spec, [{\n      op: 'replace',\n      path: '/annotations/0/text',\n      value: 'new',\n    }]);\n    expect(result.annotations?.[0].text).toBe('new');\n  });\n\n  it('add — 배열 인덱스 0에 삽입 (splice)', () => {\n    const spec = { ...baseSpec, annotations: [{ id: 'b', text: 'second' }] };\n    const result = applyPatches(spec, [{\n      op: 'add',\n      path: '/annotations/0',\n      value: { id: 'a', text: 'first' },\n    }]);\n    expect(result.annotations?.[0].id).toBe('a');\n    expect(result.annotations?.[1].id).toBe('b');\n  });\n\n  it('add — \"-\" 인덱스로 append', () => {\n    const spec = { ...baseSpec, annotations: [{ id: 'a', text: 'first' }] };\n    const result = applyPatches(spec, [{\n      op: 'add',\n      path: '/annotations/-',\n      value: { id: 'b', text: 'second' },\n    }]);\n    expect(result.annotations).toHaveLength(2);\n    expect(result.annotations?.[1].id).toBe('b');\n  });\n\n  it('replace — 범위 초과 인덱스는 no-op (sparse array 방지)', () => {\n    // JavaScript arr[999] = value → sparse array(length=1000) 버그 방지\n    const spec = { ...baseSpec, annotations: [] };\n    const result = applyPatches(spec, [{\n      op: 'replace',\n      path: '/annotations/999',\n      value: { id: 'x', text: 'ghost' },\n    }]);\n    expect(result.annotations).toHaveLength(0);\n  });\n\n  it('remove — splice로 제거', () => {\n    const spec = { ...baseSpec, annotations: [\n      { id: 'a', text: 'first' },\n      { id: 'b', text: 'second' },\n    ]};\n    const result = applyPatches(spec, [{\n      op: 'remove',\n      path: '/annotations/0',\n    }]);\n    expect(result.annotations).toHaveLength(1);\n    expect(result.annotations?.[0].id).toBe('b');\n  });\n});",
          "keywords": ["applyPatches", "RFC6901", "RFC6902", "JSON Patch", "add", "replace", "remove", "sparse array", "~0", "~1"]
        },
        {
          "name": "Zod enum 스키마 검증 테스트",
          "purpose": "TypeScript 타입과 Zod enum이 동기화되어 있는지 검증. 유효/무효 값을 모두 테스트",
          "code": "import { describe, it, expect } from 'vitest';\nimport { chartSpecSchema } from '@/lib/graph-studio/chart-spec-schema';\n\ndescribe('chartSpecSchema — ExportFormat', () => {\n  const validFormats = ['svg', 'png'];\n  const invalidFormats = ['pdf', 'tiff', 'jpg', ''];\n\n  it.each(validFormats)('%s → 유효', (format) => {\n    const spec = buildMinimalSpec({ exportFormat: format });\n    expect(chartSpecSchema.safeParse(spec).success).toBe(true);\n  });\n\n  it.each(invalidFormats)('%s → 무효', (format) => {\n    const spec = buildMinimalSpec({ exportFormat: format });\n    expect(chartSpecSchema.safeParse(spec).success).toBe(false);\n  });\n});\n\n// 팁: TypeScript 타입과 Zod enum은 항상 쌍으로 수정\n// types/graph-studio.ts: ExportFormat = 'svg' | 'png'\n// chart-spec-schema.ts: exportFormatSchema = z.enum(['svg', 'png'])",
          "keywords": ["Zod", "safeParse", "enum", "ExportFormat", "chartSpecSchema", "it.each"]
        },
        {
          "name": "순수 유틸리티 함수 테스트 (selectXYFields)",
          "purpose": "컬럼 메타데이터 기반 x/y 필드 선택 로직 검증. 단일 컬럼 fallback, 타입별 우선순위 edge case",
          "code": "import { describe, it, expect } from 'vitest';\nimport { selectXYFields } from '@/lib/graph-studio/chart-spec-utils';\nimport { CHART_TYPE_HINTS } from '@/lib/graph-studio/chart-spec-defaults';\nimport type { ColumnMeta } from '@/types/graph-studio';\n\nconst col = (name: string, type: ColumnMeta['type']): ColumnMeta => ({\n  name,\n  type,\n  uniqueCount: 5,\n  sampleValues: [],\n  hasNull: false,\n});\n\ndescribe('selectXYFields', () => {\n  it('x !== y (2개 quantitative)', () => {\n    const cols = [col('price', 'quantitative'), col('qty', 'quantitative')];\n    const { xField, yField } = selectXYFields(cols, CHART_TYPE_HINTS.scatter);\n    expect(xField).not.toBe(yField);\n  });\n\n  it('단일 컬럼 histogram: yField는 \"y\" 문자열이 아님 (실존 필드로 fallback)', () => {\n    // 버그: columns[1]?.name ?? 'y' → 존재하지 않는 'y' 반환\n    // 수정: columns.find(c => c.name !== xField)?.name ?? xField\n    const cols = [col('value', 'quantitative')];\n    const { xField, yField } = selectXYFields(cols, CHART_TYPE_HINTS.histogram);\n    expect(yField).not.toBe('y');  // 'y' 문자열이면 버그\n    expect([xField, ...cols.map(c => c.name)]).toContain(yField);\n  });\n\n  it('빈 컬럼 배열: graceful fallback', () => {\n    const { xField, yField } = selectXYFields([], CHART_TYPE_HINTS.bar);\n    expect(xField).toBe('x');\n  });\n});",
          "keywords": ["selectXYFields", "ColumnMeta", "CHART_TYPE_HINTS", "histogram", "fallback", "edge case"]
        },
        {
          "name": "DOM API 모킹 테스트 (ECharts export-utils)",
          "purpose": "document.createElement/body.appendChild 등 DOM API를 vi.spyOn으로 모킹하여 브라우저 다운로드 로직 테스트. 실행 순서(append→click→remove) 검증 포함",
          "code": "import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';\nimport { downloadChart } from '@/lib/graph-studio/export-utils';\nimport type { EChartsType } from 'echarts';\n\nfunction makeMockECharts(): EChartsType {\n  return {\n    getDataURL: vi.fn().mockReturnValue('data:image/png;base64,abc'),\n    getSvgDataURL: vi.fn().mockReturnValue('data:image/svg+xml;base64,xyz'),\n  } as unknown as EChartsType;\n}\n\ndescribe('downloadChart', () => {\n  let mockLink: { href: string; download: string; click: ReturnType<typeof vi.fn> };\n\n  beforeEach(() => {\n    mockLink = { href: '', download: '', click: vi.fn() };\n    vi.spyOn(document, 'createElement').mockReturnValue(mockLink as unknown as HTMLAnchorElement);\n    vi.spyOn(document.body, 'appendChild').mockReturnValue(mockLink as unknown as Node);\n    vi.spyOn(document.body, 'removeChild').mockReturnValue(mockLink as unknown as Node);\n  });\n\n  afterEach(() => { vi.restoreAllMocks(); });\n\n  it('null 인스턴스 → 조기 반환 (DOM 접근 없음)', () => {\n    downloadChart(null, { format: 'png', dpi: 96, width: 800, height: 600 }, 'chart');\n    expect(document.createElement).not.toHaveBeenCalled();\n  });\n\n  it('PNG: getDataURL 호출 + 96dpi → pixelRatio=1', () => {\n    const ec = makeMockECharts();\n    downloadChart(ec, { format: 'png', dpi: 96, width: 800, height: 600 }, 'result');\n    expect(ec.getDataURL).toHaveBeenCalledWith({ type: 'png', pixelRatio: 1, backgroundColor: '#ffffff' });\n    expect(mockLink.download).toBe('result.png');\n  });\n\n  it('SVG: getSvgDataURL 호출 + getDataURL 미호출', () => {\n    const ec = makeMockECharts();\n    downloadChart(ec, { format: 'svg', dpi: 96, width: 800, height: 600 }, 'fig');\n    expect(ec.getSvgDataURL).toHaveBeenCalled();\n    expect(ec.getDataURL).not.toHaveBeenCalled();\n    expect(mockLink.download).toBe('fig.svg');\n  });\n\n  it('Firefox 호환: body.appendChild → click → body.removeChild 순서', () => {\n    const order: string[] = [];\n    vi.spyOn(document.body, 'appendChild').mockImplementation(() => { order.push('append'); return mockLink as unknown as Node; });\n    vi.spyOn(document.body, 'removeChild').mockImplementation(() => { order.push('remove'); return mockLink as unknown as Node; });\n    mockLink.click = vi.fn().mockImplementation(() => { order.push('click'); });\n    downloadChart(makeMockECharts(), { format: 'png', dpi: 96, width: 800, height: 600 }, 'chart');\n    expect(order).toEqual(['append', 'click', 'remove']);\n  });\n\n  it('파일명 undefined → \"chart\" 폴백', () => {\n    downloadChart(makeMockECharts(), { format: 'png', dpi: 96, width: 800, height: 600 }, undefined);\n    expect(mockLink.download).toBe('chart.png');\n  });\n});",
          "keywords": ["vi.spyOn", "document.createElement", "body.appendChild", "DOM mock", "ECharts", "downloadChart", "Firefox"]
        }
      ]
    }
  ],
  "bestPractices": [
    {
      "title": "AAA 패턴 (Arrange-Act-Assert)",
      "description": "테스트를 3단계로 구조화하여 가독성 향상",
      "example": "it('버튼 클릭 시 카운터가 증가해야 함', () => {\n  // Arrange (준비)\n  const handleClick = jest.fn();\n  render(<Counter onClick={handleClick} />);\n  \n  // Act (실행)\n  fireEvent.click(screen.getByRole('button'));\n  \n  // Assert (검증)\n  expect(handleClick).toHaveBeenCalledTimes(1);\n  expect(screen.getByText('Count: 1')).toBeInTheDocument();\n});"
    },
    {
      "title": "테스트 이름 작성 규칙",
      "description": "명확하고 설명적인 테스트 이름 사용",
      "example": "// ❌ Bad\nit('works', () => { ... });\nit('test1', () => { ... });\n\n// ✅ Good\nit('버튼 클릭 시 모달이 열려야 함', () => { ... });\nit('잘못된 이메일 입력 시 에러 메시지가 표시되어야 함', () => { ... });\nit('로딩 중에는 스피너가 표시되고 버튼이 비활성화되어야 함', () => { ... });"
    },
    {
      "title": "단일 책임 원칙 (Single Responsibility)",
      "description": "하나의 테스트는 하나의 동작만 검증",
      "example": "// ❌ Bad: 여러 동작을 한 테스트에서 검증\nit('폼이 정상 동작해야 함', () => {\n  // 렌더링 검증\n  // 입력 검증\n  // 제출 검증\n  // 에러 검증\n});\n\n// ✅ Good: 각 동작을 별도 테스트로 분리\nit('폼이 정상 렌더링되어야 함', () => { ... });\nit('입력 필드가 정상 동작해야 함', () => { ... });\nit('제출 시 데이터가 전송되어야 함', () => { ... });\nit('검증 실패 시 에러 메시지가 표시되어야 함', () => { ... });"
    },
    {
      "title": "비동기 테스트 처리",
      "description": "waitFor, findBy를 사용하여 비동기 동작 대기",
      "example": "// ❌ Bad: 비동기 대기 없이 즉시 검증\nit('데이터 로딩 후 표시', () => {\n  render(<MyComponent />);\n  expect(screen.getByText('Data')).toBeInTheDocument();  // 실패!\n});\n\n// ✅ Good: waitFor로 비동기 대기\nit('데이터 로딩 후 표시', async () => {\n  render(<MyComponent />);\n  \n  await waitFor(() => {\n    expect(screen.getByText('Data')).toBeInTheDocument();\n  });\n});\n\n// ✅ Better: findBy 사용 (자동 대기)\nit('데이터 로딩 후 표시', async () => {\n  render(<MyComponent />);\n  \n  const data = await screen.findByText('Data');\n  expect(data).toBeInTheDocument();\n});"
    }
  ],
  "commonErrors": [
    {
      "error": "\"not wrapped in act(...)\" 경고",
      "cause": "React 상태 업데이트가 테스트 외부에서 발생",
      "solution": "waitFor를 사용하여 상태 업데이트 대기:\n\nawait waitFor(() => {\n  expect(screen.getByText('Updated')).toBeInTheDocument();\n});"
    },
    {
      "error": "\"Unable to find element\" 에러",
      "cause": "요소가 렌더링되지 않았거나 잘못된 쿼리 사용",
      "solution": "1. screen.debug()로 현재 DOM 확인\n2. getByRole, getByText 등 올바른 쿼리 사용\n3. 비동기인 경우 findBy 또는 waitFor 사용"
    },
    {
      "error": "\"Cannot read property of undefined\" 에러",
      "cause": "모킹되지 않은 의존성 호출",
      "solution": "jest.mock()으로 의존성 모킹:\n\njest.mock('@/lib/api');\nconst mockFetchData = fetchData as jest.MockedFunction<typeof fetchData>;\nmockFetchData.mockResolvedValue([]);"
    }
  ]
}